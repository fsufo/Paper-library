#pragma kernel CSMain
#pragma kernel ClearGrid
#pragma kernel MarkGrid
#pragma kernel DeleteItemsInArea

#include "ItemMover_Common.hlsl"
#include "ItemMover_Logic.hlsl"

// --- Kernels ---

[numthreads(THREAD_GROUP_GRID, 1, 1)]
void ClearGrid(uint3 id : SV_DispatchThreadID)
{
    // Support Layers
    if (id.x < Width * Height * MAX_LAYERS) Grid[id.x] = 0;
}

[numthreads(THREAD_GROUP_GRID, 1, 1)]
void MarkGrid(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= (uint)MaxItems) return;
    if (Items[id.x].active == 0) return;

    // 关键：MarkGrid 必须使用逻辑位置
    float2 pos = Items[id.x].logicPos;
    if (length(pos) < 0.001) pos = Items[id.x].pos;
    
    // Use targetHeight as layer
    int layer = (int)round(Items[id.x].targetHeight);

    int gx = (int)round(pos.x);
    int gy = (int)round(pos.y);

    if (IsValid(gx, gy))
    {
        int idx = GetIdx(gx, gy, layer);
        int orig;
        InterlockedExchange(Grid[idx], (int)id.x + 1, orig);
    }
}

[numthreads(THREAD_GROUP_X, 1, 1)]
void DeleteItemsInArea(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= (uint)MaxItems) return;
    if (Items[id.x].active == 0) return;

    if (distance(Items[id.x].pos, DelCenter) <= DelRadius)
    {
        Items[id.x].active = 0;
        Items[id.x].pos = float2(-999, -999);
        InterlockedAdd(Stats[0], Items[id.x].price);
    }
}

[numthreads(THREAD_GROUP_X, 1, 1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    if (Items[id.x].active == 0) return;

    // 1. Logic Update
    float2 logicPos = Items[id.x].logicPos;
    if (length(logicPos) < 0.001) logicPos = Items[id.x].pos;
    
    int state = Items[id.x].state;
    float dt = DeltaTime;
    float targetHeight = Items[id.x].targetHeight; // Read current target height

    int gx = (int)round(logicPos.x);
    int gy = (int)round(logicPos.y);

    if (IsValid(gx, gy))
    {
        // 核心逻辑：只调用 UpdateItem
        // 分流器逻辑已经内嵌在 UpdateItem 中
        logicPos = UpdateItem(int2(gx, gy), logicPos, dt, (int)id.x, state, targetHeight);
    }

    // 2. Visual Update
    float2 visualPos = Items[id.x].pos;
    float visualHeight = Items[id.x].height;
    
    float lerpFactor = 15.0 * dt; 
    visualPos = lerp(visualPos, logicPos, saturate(lerpFactor));
    
    // Height Lerp (Slower for smoother elevator effect?)
    // Or same speed?
    visualHeight = lerp(visualHeight, targetHeight, saturate(lerpFactor));
    
    // 如果距离非常近，直接吸附
    if (distance(visualPos, logicPos) < 0.001) visualPos = logicPos;
    if (abs(visualHeight - targetHeight) < 0.001) visualHeight = targetHeight;

    // 3. Write Back
    Items[id.x].logicPos = logicPos;
    Items[id.x].pos = visualPos;
    Items[id.x].height = visualHeight;
    Items[id.x].targetHeight = targetHeight;
    Items[id.x].state = state;
}