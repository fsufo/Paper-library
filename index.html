<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Galactic Blog</title>
    <script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
    <script src="https://unpkg.com/3d-force-graph@1.73.1/dist/3d-force-graph.min.js"></script>
    <script src="https://unpkg.com/three-spritetext@1.8.2/dist/three-spritetext.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    
    <style>
        body { margin: 0; padding: 0; overflow: hidden; background-color: #000; color: #fff; font-family: 'Segoe UI', sans-serif; cursor: url('data:image/svg+xml;utf8,<svg width="32" height="32" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M5 5L12 21L15.5 13.5L23 10L5 5Z" fill="white" stroke="%23333" stroke-width="2.5" stroke-linejoin="round" style="filter:drop-shadow(0px 2px 3px rgba(0,0,0,0.3));"/></svg>') 6 6, auto; }
        #3d-graph { width: 100vw; height: 100vh; position: absolute; z-index: 1; }
        
        ::-webkit-scrollbar { width: 6px; height: 6px; }
        ::-webkit-scrollbar-track { background: rgba(0,0,0,0.1); }
        ::-webkit-scrollbar-thumb { background: rgba(100, 150, 255, 0.3); border-radius: 3px; }
        ::-webkit-scrollbar-thumb:hover { background: rgba(100, 150, 255, 0.6); }

        .search-wrapper { position: fixed; top: 20px; right: 30px; z-index: 50; width: 240px; }
        #search-container { background: rgba(10, 15, 25, 0.85); border: 1px solid rgba(100, 150, 255, 0.3); border-radius: 20px; padding: 8px 16px; display: flex; align-items: center; backdrop-filter: blur(8px); transition: all 0.3s; }
        #search-container:focus-within { border-color: rgba(100, 200, 255, 0.9); box-shadow: 0 0 20px rgba(0, 100, 255, 0.3); }
        #search-input { background: transparent; border: none; color: #fff; outline: none; font-size: 14px; width: 100%; margin-left: 8px; font-family: inherit; }
        #search-results { margin-top: 10px; background: rgba(8, 10, 16, 0.95); border: 1px solid rgba(40, 50, 70, 0.8); border-radius: 12px; max-height: 400px; overflow-y: auto; display: none; box-shadow: 0 10px 40px rgba(0,0,0,0.8); }
        #search-results.active { display: block; }
        .search-item { padding: 12px 15px; cursor: pointer; border-bottom: 1px solid rgba(255,255,255,0.05); font-size: 13px; color: #ccc; display: flex; justify-content: space-between; align-items: center; transition: background 0.2s; }
        .search-item:hover, .search-item.selected { background: rgba(30, 100, 200, 0.3); color: #fff; }
        .search-tag { font-size: 11px; color: #88a; background: rgba(255,255,255,0.1); padding: 2px 6px; border-radius: 4px; }

        #helicopter-cat { position: fixed; pointer-events: none; z-index: 9999; transform: scale(0.65); transform-origin: top left; width: 32px; height: 24px; top: -100px; left: -100px; }
        .cat-body-container { width: 100%; height: 100%; position: relative; animation: float 2.5s ease-in-out infinite; }
        .cat-body { width: 32px; height: 22px; background: #fff; border-radius: 16px 16px 12px 12px; box-shadow: 0 0 15px rgba(255, 255, 255, 0.5); position: absolute; bottom: 0; display: flex; justify-content: center; align-items: center; }
        .cat-ear { position: absolute; top: -4px; width: 0; height: 0; border-left: 5px solid transparent; border-right: 5px solid transparent; border-bottom: 10px solid #fff; }
        .cat-ear.left { left: 3px; transform: rotate(-15deg); }
        .cat-ear.right { right: 3px; transform: rotate(15deg); }
        .cat-face { position: absolute; top: 8px; width: 100%; display: flex; justify-content: center; gap: 6px; }
        .eye { width: 3px; height: 3px; background: #333; border-radius: 50%; transition: 0.1s; }
        .eye.closed { height: 1px; transform: scaleX(1.5); background: #555; }
        .propeller { position: absolute; top: -10px; left: 50%; width: 28px; height: 2px; background: rgba(255, 255, 255, 0.9); transform: translateX(-50%); animation: spin 0.08s linear infinite; }
        .propeller::after { content: ''; position: absolute; top: 100%; left: 50%; width: 2px; height: 6px; background: #ccc; transform: translateX(-50%); }
        #zzz-bubble { position: absolute; top: -20px; right: -15px; font-size: 10px; color: #fff; font-weight: bold; opacity: 0; transition: opacity 0.5s; }
        #zzz-bubble.active { opacity: 0.9; animation: floatUp 2s infinite; }
        @keyframes floatUp { 0% { transform: translateY(0); opacity: 0.8; } 100% { transform: translateY(-10px); opacity: 0; } }
        @keyframes spin { 0% { transform: translateX(-50%) rotateY(0deg); } 100% { transform: translateX(-50%) rotateY(360deg); } }
        @keyframes float { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(4px); } }

        #article-modal { display: none; position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background: rgba(5, 5, 8, 0.96); z-index: 1000; opacity: 0; transition: opacity 0.4s ease-out; overflow-y: auto; }
        #article-modal.active { opacity: 1; }
        .article-content { max-width: 800px; margin: 60px auto; padding: 40px; background: rgba(20, 25, 35, 0.4); border: 1px solid rgba(255,255,255,0.1); border-radius: 12px; }
        .close-btn { position: fixed; top: 30px; right: 50px; font-size: 32px; cursor: pointer; color: #888; z-index: 1100; }
        .close-btn:hover { color: #fff; }
        .markdown-body { line-height: 1.7; color: #d0d7de; }
        .markdown-body h1 { border-bottom: 1px solid #30363d; padding-bottom: 0.3em; margin-top: 1.5em; color: #fff; }
        .markdown-body a { color: #58a6ff; text-decoration: none; }
        .markdown-body code { background: rgba(110, 118, 129, 0.4); padding: 0.2em 0.4em; border-radius: 6px; font-family: monospace; }
        .markdown-body pre { background: #161b22; padding: 16px; border-radius: 6px; overflow: auto; }
        .markdown-body img { max-width: 100%; border-radius: 6px; }
    </style>
</head>
<body>
    <div id="3d-graph"></div>
    <div id="helicopter-cat"><div class="cat-body-container"><div id="zzz-bubble">Zzz...</div><div class="propeller"></div><div class="cat-ear left"></div><div class="cat-ear right"></div><div class="cat-body"><div class="cat-face"><div class="eye left"></div><div class="eye right"></div></div></div></div></div>
    
    <!-- Settings Panel -->
    <div id="settings-panel" style="position: fixed; bottom: 20px; left: 20px; z-index: 99; background: rgba(10, 15, 25, 0.85); padding: 15px; border-radius: 12px; border: 1px solid rgba(100, 150, 255, 0.2); backdrop-filter: blur(5px); color: #ccc; font-size: 13px; font-family: 'Segoe UI', sans-serif;">
        <div style="margin-bottom: 8px; font-weight: bold; color: #fff; border-bottom: 1px solid rgba(255,255,255,0.1); padding-bottom: 5px;">View Settings</div>
        <div style="display: flex; flex-direction: column; gap: 8px;">
            <label style="cursor: pointer; display: flex; align-items: center;"><input type="checkbox" id="chk-wiki" onchange="updateGraphFilter()" style="margin-right: 8px; accent-color: #00ccff;">Show Wiki Links [[ ]]</label>
            <label style="cursor: pointer; display: flex; align-items: center;"><input type="checkbox" id="chk-md" checked onchange="updateGraphFilter()" style="margin-right: 8px; accent-color: #ffaa00;">Show MD Links [ ]</label>
            <label style="cursor: pointer; display: flex; align-items: center;"><input type="checkbox" id="chk-gravity" checked onchange="updateGraphFilter()" style="margin-right: 8px; accent-color: #ff1133;">Enable Tag Gravity</label>
        </div>
    </div>

    <div class="search-wrapper"><div id="search-container"><span class="search-icon">üîç</span><input type="text" id="search-input" placeholder="Search universe..." autocomplete="off"/></div><div id="search-results"></div></div>
    <div id="article-modal"><div class="close-btn" onclick="closeArticle()">&times;</div><div class="article-content markdown-body" id="markdown-container"></div></div>
    
    <script>
        let gData = null; // Store full data globally
        let activeLookup = {}; // Áã¨Á´ãÁöÑÂÖ®Â±ÄÊü•ÊâæË°®ÔºåËß£ËÄ¶ Node ÂØπË±°

        function updateGraphFilter() {
            if(!gData || !Graph) return;
            
            const showWiki = document.getElementById('chk-wiki').checked;
            const showMd = document.getElementById('chk-md').checked;
            const enableGravity = document.getElementById('chk-gravity').checked;
            
            // 1. Filter valid links
            let filteredLinks = gData.links.filter(l => {
                // Keep cluster links only if gravity is enabled
                if (l.isClusterLink) return enableGravity;
                
                // Keep normal links based on type
                if (l.type === 'wiki') return showWiki;
                if (l.type === 'md') return showMd;
                return true; // Default keep others
            });

            // 2. Clone structure 
            Graph.graphData({
                nodes: gData.nodes,
                links: filteredLinks
            });

            // 3. Adjust Physics
            const chargeStrength = enableGravity ? -120 : -60;
            Graph.d3Force('charge').strength(chargeStrength);

            // 4. ÈáçÂª∫Ê¥ªË∑ÉÈÇªÂ±ÖÁ¥¢Âºï (‰ΩøÁî®ÂÖ®Â±ÄÂ≠óÂÖ∏Ôºå‰∏çÂÜç‰æùËµñ Node ÂØπË±°Â±ûÊÄß)
            activeLookup = {}; // Ê∏ÖÁ©∫
            
            // ËæÖÂä©ÂáΩÊï∞ÔºöÂÆâÂÖ®Ëé∑Âèñ ID
            const getID = (n) => (typeof n === 'object') ? n.id : n;

            filteredLinks.forEach(link => {
                // ÊâÄÊúâÁªèËøáÁ≠õÈÄâÁöÑËøûÊé•ÔºàÂåÖÊã¨ Tag Cluster ÈìæÊé•ÔºâÈÉΩÂ∫îÂèÇ‰∏éÈ´ò‰∫ÆËÆ°ÁÆó
                // if(link.isClusterLink) return; 

                const sId = getID(link.source);
                const tId = getID(link.target);

                // ÂàùÂßãÂåñ
                if(!activeLookup[sId]) activeLookup[sId] = { neighbors: [], links: [] };
                if(!activeLookup[tId]) activeLookup[tId] = { neighbors: [], links: [] };

                // ËÆ∞ÂΩïÂÖ≥Á≥ª (Âè™Â≠ò IDÔºåÊ∏≤ÊüìÊó∂ÂÜçÊâæÂØπË±°ÔºåÈÅøÂÖçÂºïÁî®Èîô‰π±)
                activeLookup[sId].neighbors.push(tId);
                activeLookup[sId].links.push(link);

                activeLookup[tId].neighbors.push(sId);
                activeLookup[tId].links.push(link);
            });
            
            // Re-apply link coloring
            setTimeout(() => {
                const currentLinks = Graph.graphData().links.filter(l => !l.isClusterLink);
                currentLinks.forEach(link => {
                    if(link.__lineObj && link.sourceNode && link.targetNode) {
                        // Re-trigger color update
                        const c1 = new THREE.Color(link.sourceNode.color), c2 = new THREE.Color(link.targetNode.color);
                        const attr = link.__lineObj.geometry.attributes.color;
                        attr.setXYZ(0, c1.r, c1.g, c1.b); attr.setXYZ(1, c1.r, c1.g, c1.b);
                        attr.setXYZ(3, c2.r, c2.g, c2.b); attr.setXYZ(4, c2.r, c2.g, c2.b);
                        attr.needsUpdate = true;
                    }
                });
            }, 100);
        }
        // MD ÈìæÊé•Âä´ÊåÅÁ≥ªÁªü
        document.getElementById('markdown-container').addEventListener('click', function(e) {
            if(e.target.tagName === 'A') {
                e.preventDefault();
                const href = e.target.getAttribute('href');
                
                // 1. Â∞ùËØï‰Ωú‰∏∫ÂÜÖÈÉ®ÈìæÊé•Â§ÑÁêÜ
                // ÂéªÊéâË∑ØÂæÑÂâçÁºÄ ./posts/ Á≠âÔºå‰øùÁïôÊñá‰ª∂Âêç
                let targetId = href.split('/').pop(); 
                // Â∞ùËØïÂåπÈÖç graph ‰∏≠ÁöÑ ID (ÈÄöÂ∏∏ÊòØ filename.md)
                const { nodes } = Graph.graphData();
                let targetNode = nodes.find(n => n.id === targetId || n.id === targetId + '.md');
                
                // 2. Â¶ÇÊûúÊ≤°ÊâæÂà∞ÔºåÂ∞ùËØïÊ®°Á≥äÂåπÈÖç (ÊØîÂ¶ÇÈìæÊé•ÂÜôÁöÑÊòØ title)
                if(!targetNode) {
                    const cleanRef = decodeURIComponent(targetId).replace(/\.md$/i, '').toLowerCase();
                    targetNode = nodes.find(n => n.label.toLowerCase() === cleanRef || n.id.toLowerCase().includes(cleanRef));
                }

                if(targetNode) {
                    console.log('Jumping to internal link:', targetNode.label);
                    // ÂÖ≥Èó≠ÂΩìÂâçÊñáÁ´†ÔºåÈ£ûË°åÂπ∂Âú®È£ûË°åÁªìÊùüÂêéÊâìÂºÄÊñ∞ÊñáÁ´†
                    // Á®çÂæÆÁº©Áü≠‰∏ÄÁÇπÈ£ûË°åÊó∂Èó¥Ôºå‰ΩìÈ™åÊõ¥ÊµÅÁïÖ
                    const cam = Graph.camera();
                    const startPos = { x: cam.position.x, y: cam.position.y, z: cam.position.z };
                    
                    // ËßÜËßâ‰∏äÁöÑ‚ÄúÈ£ûË∂ä‚Äù
                    closeArticle(); 
                    
                    // ÈáçÊñ∞ÊâìÂºÄ
                    setTimeout(() => {
                         jumpToNode(targetNode.id, true);
                    }, 300); // Á≠âÂæÖ modal ÂÖ≥Èó≠Âä®ÁîªÁöÑ‰∏ÄÂçä
                } else {
                    // Â§ñÈÉ®ÈìæÊé•ÔºåÊñ∞Ê†áÁ≠æÈ°µÊâìÂºÄ
                    window.open(href, '_blank');
                }
            }False
        });

        let Graph, maxDegree = 1;
        let highlightNodes = new Set(), highlightLinks = new Set();
        let hoverNode = null, initialCameraPos = null, starryParticles = null;

        const modal = document.getElementById('article-modal');
        const box = document.getElementById('markdown-container');
        
        // Ê†∏ÂøÉ‰∫§‰∫íÔºöÊâìÂºÄÊñáÁ´†
        function openArticle(node) {
            if(!node) return;
            const content = node.content || (node.data && node.data.content) || "# No Content";
            box.innerHTML = marked.parse(content);
            modal.style.display = 'block';
            modal.offsetHeight; // Force reflow
            modal.classList.add('active');
            
            // ÊâìÂºÄÊñáÁ´†Êó∂ÔºåËÆ©Áå´Áå´Áù°ËßâÔºåÈÅøÂÖçÈÅÆÊå°
            const cat = document.getElementById('helicopter-cat');
            if(cat) cat.classList.add('hidden');
        }
        function closeArticle() {
            modal.classList.remove('active');
            setTimeout(() => { modal.style.display = 'none'; }, 400);
            if(initialCameraPos && Graph) Graph.cameraPosition(initialCameraPos, {x:0,y:0,z:0}, 1500);
            
            // Âî§ÈÜíÁå´Áå´
            const cat = document.getElementById('helicopter-cat');
            if(cat) cat.classList.remove('hidden');
        }
        document.addEventListener('keydown', e => { if(e.key==='Escape') closeArticle(); });

        // Ëâ≤Ê∏©ÁÆóÊ≥ï (È´òÈ•±ÂíåÂ∫¶)
        function getStarColor(degree) {
            const t = Math.pow(degree / maxDegree, 0.7); 
            // Saturation Boosted: Red -> Orange -> Cyan/Blue
            const c1 = new THREE.Color(0xff1133), c2 = new THREE.Color(0xffaa00), c3 = new THREE.Color(0x00ccff);
            if (t < 0.4) return c1.clone().lerp(c2, t * 2.5).getStyle();
            else return c2.clone().lerp(c3, (t - 0.4) * 1.6).getStyle();
        }

        // ËßÜËßâÁîüÊàêÂô® (Êõ¥ÈïøÊõ¥ÁªÜÁöÑÂçÅÂ≠ó)
        function createGlowSprite(color, size, degree) {
            const canvas = document.createElement('canvas'); canvas.width = 256; canvas.height = 256; 
            const ctx = canvas.getContext('2d'); const c = 128; // Center
            
            // Core Glow
            const grad = ctx.createRadialGradient(c, c, 4, c, c, 40);
            grad.addColorStop(0, 'rgba(255,255,255,1)'); grad.addColorStop(0.3, color); grad.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle = grad; ctx.beginPath(); ctx.arc(c, c, 40, 0, Math.PI*2); ctx.fill();
            
            // Cross Rays
            ctx.globalCompositeOperation = 'lighter';
            const rayScale = 0.8 + (degree / maxDegree) * 0.5;
            const drawRay = (w, h, a) => {
                const g = ctx.createLinearGradient(0, c-h, 0, c+h);
                g.addColorStop(0,'rgba(0,0,0,0)'); g.addColorStop(0.5,`rgba(255,255,255,${a})`); g.addColorStop(1,'rgba(0,0,0,0)');
                ctx.fillStyle = g; ctx.fillRect(c-w/2, c-h, w, h*2);
            };
            // Main Cross (Long)
            drawRay(4, 100*rayScale, 0.9);
            ctx.save(); ctx.translate(c, c); ctx.rotate(Math.PI/2); ctx.translate(-c, -c); 
            drawRay(4, 80*rayScale, 0.9); 
            ctx.restore();
            
            const mat = new THREE.SpriteMaterial({ map: new THREE.CanvasTexture(canvas), transparent: true, blending: THREE.AdditiveBlending, depthWrite: false });
            const sprite = new THREE.Sprite(mat);
            const finalSize = size * (1 + (degree/maxDegree)*0.5);
            sprite.scale.set(finalSize, finalSize, 1);
            sprite.userData = { phase: Math.random()*Math.PI*2, baseScale: finalSize, currentOpacity: 1.0, speed: 0.5+Math.random() };
            return sprite;
        }

        // ÂàùÂßãÂåñÂõæË°®
        Graph = ForceGraph3D()(document.getElementById('3d-graph'))
            .jsonUrl('./posts_data.json')
            .backgroundColor('#000000')
            .nodeLabel(null)
            .linkThreeObject(link => {
                const geo = new THREE.BufferGeometry();
                geo.setAttribute('position', new THREE.BufferAttribute(new Float32Array(6), 3));
                geo.setAttribute('color', new THREE.BufferAttribute(new Float32Array([0.5,0.5,0.5, 0.5,0.5,0.5]), 3));
                // ÂèçÂêëÈìæÊé•ÂÆåÂÖ®ÈÄèÊòéÔºå‰∏çÂπ≤Êâ∞ËßÜËßâÔºåÂè™Êèê‰æõÁ≤íÂ≠êË∑ØÂæÑ
                const opacity = link.isReverse ? 0 : 0.15;
                const mat = new THREE.LineBasicMaterial({ vertexColors: true, transparent: true, opacity: opacity });
                const line = new THREE.Line(geo, mat); link.__lineObj = line; return line;
            })
            .linkPositionUpdate((line, { start, end }) => {
                const p = line.geometry.attributes.position.array;
                p[0]=start.x; p[1]=start.y; p[2]=start.z; p[3]=end.x; p[4]=end.y; p[5]=end.z;
                line.geometry.attributes.position.needsUpdate = true; return true; 
            })
            .nodeThreeObject(node => {
                const degree = (node.neighbors && node.neighbors.length) || 0;
                let color = getStarColor(degree); node.color = color; 
                const group = new THREE.Group();
                
                // ÊòüÁêÉÊú¨‰Ωì
                const sprite = createGlowSprite(color, 12, degree); 
                group.add(sprite); group.sprite = sprite;
                
                // Ê†áÈ¢ò (ÁôΩËâ≤)
                const text = new SpriteText(node.label); 
                text.color = '#fff'; text.textHeight = 4; text.position.y = -18;
                text.material.transparent = true; text.material.opacity = 0; text.material.depthWrite = false;
                group.add(text); group.text = text; 
                
                // Tag Ê†áÁ≠æ (ÁÅ∞Ëâ≤ÔºåÂ∞èÂ≠ó‰Ωì)
                const tagStr = node.group || '';
                const subText = new SpriteText(tagStr ? `#${tagStr}` : '');
                subText.color = '#88a'; subText.textHeight = 2.5; subText.position.y = -24;
                subText.material.transparent = true; subText.material.opacity = 0; subText.material.depthWrite = false;
                group.add(subText); group.subText = subText;

                return group;
            })
            .onNodeHover(node => {
                if(modal.classList.contains('active')) return;
                hoverNode = node || null; document.body.style.cursor = node ? 'pointer' : null;
                highlightNodes.clear(); highlightLinks.clear();
                
                if (node) {
                    highlightNodes.add(node);
                    
                    // ‰ΩøÁî®ÂÖ®Â±ÄÊü•ÊâæË°® activeLookup
                    const entry = activeLookup[node.id];
                    if(entry) {
                        // ÊâæÂõû Node ÂØπË±°Âπ∂È´ò‰∫Æ
                        const { nodes } = Graph.graphData();
                        entry.neighbors.forEach(nid => {
                            const neighborNode = nodes.find(n => n.id === nid);
                            if(neighborNode) highlightNodes.add(neighborNode);
                        });
                        // È´ò‰∫ÆËøûÁ∫ø
                        entry.links.forEach(l => highlightLinks.add(l));
                    }
                }

                // Âä®ÊÄÅÊõ¥Êñ∞Á≤íÂ≠êÊµÅÂêë (Cluster Link ‰∏çÊòæÁ§∫Á≤íÂ≠ê)
                Graph.linkDirectionalParticles(link => (highlightLinks.has(link) && !link.isClusterLink) ? 3 : 0);
                // Á≤íÂ≠êË∂ÖÂæÆÂ∞è (0.6)ÔºåÈ¢úËâ≤Âº∫Âà∂Ë∑üÈöèÊ∫êÊòüÁêÉÈ¢úËâ≤
                Graph.linkDirectionalParticleWidth(link => highlightLinks.has(link) ? 1.5 : 0);
                Graph.linkDirectionalParticleColor(link => link.sourceNode ? link.sourceNode.color : '#ffffff'); 
                Graph.linkDirectionalParticleSpeed(link => 0.005);
            })
            .onNodeClick(node => {
                if(!node) return;
                const cam = Graph.camera(); initialCameraPos = { x: cam.position.x, y: cam.position.y, z: cam.position.z };
                const ratio = 1 + 60/Math.hypot(node.x, node.y, node.z);
                Graph.cameraPosition({ x: node.x*ratio, y: node.y*ratio, z: node.z*ratio }, node, 1000);
                setTimeout(() => openArticle(node), 1000);
            });

        // Êï∞ÊçÆÂ§ÑÁêÜ
        fetch('./posts_data.json').then(r => r.json()).then(data => {
            const map = {};
            const tagGroups = {};

            // 1. Âª∫Á´ãÁ¥¢Âºï & ÂàÜÁªÑ Tag
            data.nodes.forEach(n => { 
                n.neighbors = []; 
                map[n.id] = n; 
                
                // Tag Clustering Logic
                const tag = n.group || 'default';
                if(!tagGroups[tag]) tagGroups[tag] = [];
                tagGroups[tag].push(n);
            });

            // 2. ‰∏∫Áõ∏Âêå Tag ÁöÑËäÇÁÇπÂàõÂª∫ÈöêÂΩ¢ÂºïÂäõÈìæÊé•
            Object.keys(tagGroups).forEach(tag => {
                const nodes = tagGroups[tag];
                if(nodes.length > 1) {
                    const hub = nodes[0];
                    for(let i=1; i<nodes.length; i++) {
                        data.links.push({ source: nodes[i].id, target: hub.id, isClusterLink: true });
                    }
                }
            });

            // 3. Â§ÑÁêÜÂÆû‰ΩìÈìæÊé• & È¢ÑÂ§ÑÁêÜ (Âê´ÂèåÂêëWikiÂ§ÑÁêÜ)
            const extraLinks = [];
            data.links.forEach(l => {
                // Ensure type exists (default to 'wiki' if undefined for compatibility)
                if(!l.isClusterLink && !l.type) l.type = 'wiki';

                // Wiki Link: Ê∑ªÂä†ÂèçÂêëÁöÑËßÜËßâ Link ‰ª•ÂÆûÁé∞ÂèåÂêëÁ≤íÂ≠ê
                if(l.type === 'wiki') {
                    extraLinks.push({ 
                        source: l.target, 
                        target: l.source, 
                        type: 'wiki', 
                        isReverse: true 
                    });
                }
            });
            data.links.push(...extraLinks);

            data.links.forEach(l => {
                // Pre-resolve objects for ForceGraph
                const a = map[l.source], b = map[l.target];
                if(a && b) { 
                    // ‰ªÖÊ≠£Âêë/ÈùûclusterÈìæÊé•ÂèÇ‰∏éÈÇªÂ±ÖÁªüËÆ° (ÂèçÂêëÈìæÊé•‰ªÖ‰Ωú‰∏∫ËßÜËßâËæÖÂä©)
                    if(!l.isClusterLink && !l.isReverse) { a.neighbors.push(b); b.neighbors.push(a); }
                    l.sourceNode = a; l.targetNode = b; 
                }
            });

            maxDegree = 0; data.nodes.forEach(n => { if(n.neighbors.length > maxDegree) maxDegree = n.neighbors.length; });
            if(maxDegree < 1) maxDegree = 1;

            // Save to Global
            gData = data;

            // Initialize Layout via Filter function
            // 4. ÂÆöÂà∂ËÅöÁ±ªÂäõ
            Graph.d3Force('charge').strength(-120); 
            Graph.d3Force('link').distance(link => link.isClusterLink ? 40 : 100).strength(link => link.isClusterLink ? 0.05 : 1);
            
            updateGraphFilter(); // Initial Render
        });

        // Âä®ÁîªÂæ™ÁéØ
        function animateFrame() {
            requestAnimationFrame(animateFrame);
            const { nodes, links } = Graph.graphData();
            if(!nodes || nodes.length === 0) return;
            
            const camPos = Graph.camera().position;
            const camDist = Math.hypot(camPos.x, camPos.y, camPos.z);
            const time = Date.now() * 0.002;
            const isHovering = (hoverNode !== null);

            // Á≤íÂ≠êÁ≥ªÁªüShaderÊé•ÁÆ°‰∫ÜËÉåÊôØÊ∂àÈöêÔºåÊ≠§Â§Ñ‰ªÖÂ§ÑÁêÜGraphÈÄªËæë

            const isModalOpen = modal.classList.contains('active');

            nodes.forEach(node => {
                const group = node.__threeObj; if (!group) return;
                const dist = Math.hypot(node.x-camPos.x, node.y-camPos.y, node.z-camPos.z);
                
                // Ê†áÈ¢ò & Tag LOD (ÊñáÁ´†ÊâìÂºÄÊó∂Âº∫Âà∂ÈöêËóè)
                let textOp = 0;
                if(!isModalOpen) {
                    if(isHovering) { if(highlightNodes.has(node)) textOp = 1; }
                    // Â¢ûÂä†ÂèØËßÜË∑ùÁ¶ªÔºö‰ªé 200 ÊèêÂçáÂà∞ 500Ôºå‰∏îË°∞ÂáèÊõ¥Âπ≥Áºì
                    else { 
                        if(dist < 500) textOp = 1 - (dist - 150)/350; 
                    }
                    if(textOp<0)textOp=0; if(textOp>1)textOp=1;
                }
                // Âπ≥ÊªëËøáÊ∏°
                group.text.material.opacity += (textOp - group.text.material.opacity) * 0.15;
                // TagÊØîÊ†áÈ¢òÁ®çÂæÆÊ∑°‰∏ÄÁÇπÔºåÊàñËÄÖÂêåÊ≠•
                group.subText.material.opacity = group.text.material.opacity * 0.7;
                
                // Êú¨‰ΩìÊ∂àÈöê
                let targetOp = (isHovering && !highlightNodes.has(node)) ? 0.1 : 1.0;
                group.sprite.userData.currentOpacity += (targetOp - group.sprite.userData.currentOpacity) * 0.1;
                group.sprite.material.opacity = group.sprite.userData.currentOpacity;
                
                // ÂëºÂê∏
                if(group.sprite.userData.currentOpacity > 0.5) {
                    const s = 1 + Math.sin(time * group.sprite.userData.speed + group.sprite.userData.phase) * 0.08;
                    const b = group.sprite.userData.baseScale;
                    group.sprite.scale.set(b*s, b*s, 1);
                }
            });
            
            links.forEach(link => {
                const line = link.__lineObj; if(!line) return;
                let t = 0.15;
                if(isHovering) t = highlightLinks.has(link) ? 0.8 : 0.02;
                line.material.opacity += (t - line.material.opacity) * 0.1;
            });
        }
        animateFrame();

        // ÊêúÁ¥¢Á≥ªÁªü
        const searchInput = document.getElementById('search-input');
        const searchResults = document.getElementById('search-results');
        let searchIndex = -1;

        function jumpToNode(id, openDoc = false) {
            const { nodes } = Graph.graphData();
            const node = nodes.find(n => n.id === id);
            if(node) {
                const ratio = 1 + 60/Math.hypot(node.x, node.y, node.z);
                Graph.cameraPosition({ x: node.x*ratio, y: node.y*ratio, z: node.z*ratio }, node, 800);
                
                // Highlight
                hoverNode = node; highlightNodes.clear(); highlightNodes.add(node);
                if(node.neighbors) node.neighbors.forEach(n => highlightNodes.add(n));
                
                if(openDoc) {
                    setTimeout(() => openArticle(node), 800);
                    searchInput.value = ''; searchResults.classList.remove('active');
                }
            }
        }

        searchInput.addEventListener('input', (e) => {
            const val = e.target.value.toLowerCase().trim();
            if(!val) { searchResults.classList.remove('active'); return; }
            
            const matches = Graph.graphData().nodes.map(n => {
                let score = 0, l = (n.label||'').toLowerCase(), i = (n.id||'').toLowerCase();
                if(l===val) score+=20; else if(l.startsWith(val)) score+=10; else if(l.includes(val)) score+=5;
                if(i.includes(val)) score+=3;
                return { n, score };
            }).filter(o => o.score>0).sort((a,b)=>b.score-a.score).slice(0, 10);

            if(matches.length > 0) {
                searchResults.innerHTML = matches.map((m, idx) => `
                    <div class="search-item" data-id="${m.n.id}" data-idx="${idx}">
                        <span class="label">${m.n.label}</span>
                        <span class="search-tag">${m.n.group||'post'}</span>
                    </div>`).join('');
                searchResults.classList.add('active');
                
                document.querySelectorAll('.search-item').forEach(el => {
                    el.addEventListener('mouseenter', () => { // Hover Preview
                        searchIndex = parseInt(el.dataset.idx);
                        updateSelection();
                        jumpToNode(el.dataset.id, false); 
                    });
                    el.addEventListener('click', () => jumpToNode(el.dataset.id, true)); // Click Confirm
                });
            } else searchResults.classList.remove('active');
            searchIndex = -1;
        });

        searchInput.addEventListener('keydown', (e) => {
            const items = document.querySelectorAll('.search-item');
            if(!searchResults.classList.contains('active')) return;
            if(e.key === 'ArrowDown' || e.key === 'ArrowUp') {
                e.preventDefault();
                searchIndex = (e.key === 'ArrowDown') ? (searchIndex+1)%items.length : (searchIndex-1+items.length)%items.length;
                updateSelection();
                if(items[searchIndex]) jumpToNode(items[searchIndex].dataset.id, false);
            } else if(e.key === 'Enter') {
                e.preventDefault();
                const target = searchIndex >= 0 ? items[searchIndex] : items[0];
                if(target) jumpToNode(target.dataset.id, true);
            }
        });
        function updateSelection() {
            const items = document.querySelectorAll('.search-item');
            items.forEach(el => el.classList.remove('selected'));
            if(items[searchIndex]) { items[searchIndex].classList.add('selected'); items[searchIndex].scrollIntoView({block:'nearest'}); }
        }

        // ËÉåÊôØÊòüÁ©∫ (‰øÆÂ§çÁâàÔºöÁ°Æ‰øùÂèØËßÅÊÄß + Ë∑ùÁ¶ªÊ∏êÈöê)
        setTimeout(() => {
            // 1. Ë∞ÉÊï¥Áõ∏Êú∫ËßÜË∑ùÔºåÁ°Æ‰øùËÉΩÁúãÂà∞ËøúÂ§ÑÁöÑÊòüÊòü
            if(Graph.camera()) {
                Graph.camera().far = 20000;
                Graph.camera().updateProjectionMatrix();
            }

            const geo = new THREE.BufferGeometry();
            const pos = [], cols = [];
            for(let i=0; i<6000; i++) {
                // ÁîüÊàêÂú® 300 - 6000 Ë∑ùÁ¶ªÁöÑÁêÉÂ£≥ÂÜÖ
                const r = 5000 * Math.pow(Math.random(), 0.4) + 300; 
                const theta = Math.random()*Math.PI*2, phi = Math.acos(2*Math.random()-1);
                pos.push(r*Math.sin(phi)*Math.cos(theta), r*Math.sin(phi)*Math.sin(theta), r*Math.cos(phi));
                
                // È¢úËâ≤ÈöèÊú∫ÔºåÂ∏¶‰∏ÄÁÇπËìùÁ¥´Ëâ≤Ë∞É
                const c = new THREE.Color().setHSL(0.6 + Math.random()*0.2, 0.4, 0.8); 
                cols.push(c.r, c.g, c.b);
            }
            geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
            geo.setAttribute('color', new THREE.Float32BufferAttribute(cols, 3));

            // ‰ΩøÁî®Ê†áÂáÜÊùêË¥® + shaderÊ≥®ÂÖ•ÔºåÁ°Æ‰øùÊúÄÂ§ßÂÖºÂÆπÊÄß
            const mat = new THREE.PointsMaterial({
                size: 3,
                vertexColors: true,
                transparent: true,
                opacity: 0.8,
                sizeAttenuation: true,
                depthWrite: false,
                blending: THREE.AdditiveBlending
            });

            // Ê≥®ÂÖ• Shader ÈÄªËæëÔºöË∑ùÁ¶ªÁõ∏Êú∫ËøëÊó∂ÈÄèÊòéÂ∫¶Èôç‰Ωé
            mat.onBeforeCompile = shader => {
                shader.vertexShader = `
                    varying float vDist;
                    ${shader.vertexShader}
                `.replace(
                    '#include <begin_vertex>',
                    `
                    #include <begin_vertex>
                    vec4 mvPos = modelViewMatrix * vec4( position, 1.0 );
                    vDist = length( mvPos.xyz );
                    `
                );
                shader.fragmentShader = `
                    varying float vDist;
                    ${shader.fragmentShader}
                `.replace(
                    'vec4 diffuseColor = vec4( diffuse, opacity );',
                    `
                    // Ë∑ùÁ¶ª < 200 Ê∏êÈöê
                    float fade = smoothstep(100.0, 300.0, vDist);
                    // ÂúÜÂΩ¢Á≤íÂ≠êË£ÅÂàá
                    vec2 xy = gl_PointCoord.xy - vec2(0.5);
                    float alpha = (1.0 - smoothstep(0.3, 0.5, length(xy))) * fade * opacity;
                    vec4 diffuseColor = vec4( diffuse, alpha );
                    `
                );
            };

            starryParticles = new THREE.Points(geo, mat);
            Graph.scene().add(starryParticles);
        }, 1500); // Á®çÂæÆÂª∂Âêé‰∏ÄÁÇπÁ°Æ‰øùÂú∫ÊôØÂä†ËΩΩÂÆåÊàê

        // Áå´Áå´Ë∑üÈöè
        const cat = document.getElementById('helicopter-cat');
        if(cat) {
            const body = cat.querySelector('.cat-body-container');
            const lEye = cat.querySelector('.eye.left'), rEye = cat.querySelector('.eye.right'), zzz = document.getElementById('zzz-bubble');
            let mx=window.innerWidth/2, my=window.innerHeight/2, cx=mx, cy=my, rot=0, sleeping=false, lastT=Date.now();
            document.addEventListener('mousemove', e=>{ mx=e.clientX; my=e.clientY; lastT=Date.now(); if(sleeping)wake(); });
            
            function wake() { sleeping=false; lEye.classList.remove('closed'); rEye.classList.remove('closed'); zzz.classList.remove('active'); blink(); }
            function sleep() { sleeping=true; lEye.classList.add('closed'); rEye.classList.add('closed'); zzz.classList.add('active'); }
            function blink() { if(sleeping)return; lEye.classList.add('closed'); rEye.classList.add('closed'); setTimeout(()=>{if(!sleeping){lEye.classList.remove('closed');rEye.classList.remove('closed')}}, 200); setTimeout(blink, 2000+Math.random()*3000); }
            setTimeout(blink,2000);

            function loop() {
                if(!sleeping && Date.now()-lastT>5000) sleep();
                cx += (mx+20-cx)*0.08; cy += (my+20-cy)*0.08;
                let vx = (mx+20-cx), tr = Math.max(-20, Math.min(20, vx*-1.5));
                rot += (tr-rot)*0.1;
                cat.style.left = cx+'px'; cat.style.top = cy+'px';
                body.style.transform = `rotate(${rot}deg)`;
                requestAnimationFrame(loop);
            }
            loop();
        }
        window.onresize = () => Graph.width(window.innerWidth).height(window.innerHeight);
    </script>
</body>
</html>