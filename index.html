<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Galactic Blog</title>
    <!-- Favicon: Super Cute Cat (Blush) -->
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAzMiAzMiI+PCEtLSBFYXJzIChMb3dlcmVkKSAtLT48cGF0aCBkPSJNNSAxMSBMMTEgMTEgTDggNiBaIiBmaWxsPSIjZmZmZmZmIiBzdHJva2U9IiNmZmZmZmYiIHN0cm9rZS13aWR0aD0iMiIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIgdHJhbnNmb3JtPSJyb3RhdGUoLTE1IDggMTEpIi8+PHBhdGggZD0iTTI3IDExIEwyMSAxMSBMMjQgNiBaIiBmaWxsPSIjZmZmZmZmIiBzdHJva2U9IiNmZmZmZmYiIHN0cm9rZS13aWR0aD0iMiIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIgdHJhbnNmb3JtPSJyb3RhdGUoMTUgMjQgMTEpIi8+PHJlY3QgeD0iMyIgeT0iNyIgd2lkdGg9IjI2IiBoZWlnaHQ9IjIwIiByeD0iMTMiIHJ5PSIxMyIgZmlsbD0iI2ZmZmZmZiIgc3Ryb2tlPSJub25lIi8+PGVsbGlwc2UgY3g9IjciIGN5PSIyMCIgcng9IjIiIHJ5PSIxLjUiIGZpbGw9IiNmZmRhZGEiLz48ZWxsaXBzZSBjeD0iMjUiIGN5PSIyMCIgcng9IjIiIHJ5PSIxLjUiIGZpbGw9IiNmZmRhZGEiLz48Y2lyY2xlIGN4PSIxMC41IiBjeT0iMTciIHI9IjIuNSIgZmlsbD0iIzMzMzMzMyIvPjxjaXJjbGUgY3g9IjIxLjUiIGN5PSIxNyIgcj0iMi41IiBmaWxsPSIjMzMzMzMzIi8+PC9zdmc+">
    <script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
    <script src="https://unpkg.com/3d-force-graph@1.73.1/dist/3d-force-graph.min.js"></script>
    <script src="https://unpkg.com/three-spritetext@1.8.2/dist/three-spritetext.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    
    <style>
        /* å¼ºåˆ¶å…¨å±€å…‰æ ‡ä¸ºè‡ªå®šä¹‰çŒ«çŒ«æ ·å¼ï¼Œè¦†ç›–é»˜è®¤ */
        :root {
            --custom-cursor: url('data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzIiIGhlaWdodD0iMzIiIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBkPSJNNSA1TDEyIDIxTDE1LjUgMTMuNUwyMyAxMEw1IDVaIiBmaWxsPSJ3aGl0ZSIgc3Ryb2tlPSIjMzMzIiBzdHJva2Utd2lkdGg9IjIuNSIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIgc3R5bGU9ImZpbHRlcjpkcm9wLXNoYWRvdygwcHggMnB4IDNweCByZ2JhKDAsMCwwLDAuMykpOyIvPjwvc3ZnPg==') 6 6, auto;
        }
        
        *, html, body, canvas, a, button, .clickable, .tag-capsule, .search-item {
            cursor: var(--custom-cursor) !important;
        }

        /* ä¼˜åŒ–èƒŒæ™¯ï¼šçº¯é»‘åº•è‰²ï¼Œç”± WebGL Skybox æ¥ç®¡ç¯å¢ƒæ¸²æŸ“ */
        body { 
            margin: 0; padding: 0; overflow: hidden; 
            background-color: #000000; 
            color: #fff; font-family: 'Segoe UI', sans-serif; 
        }
        #3d-graph { width: 100vw; height: 100vh; position: absolute; z-index: 1; }
        
        ::-webkit-scrollbar { width: 6px; height: 6px; }
        ::-webkit-scrollbar-track { background: rgba(0,0,0,0.1); }
        ::-webkit-scrollbar-thumb { background: rgba(100, 150, 255, 0.3); border-radius: 3px; }
        ::-webkit-scrollbar-thumb:hover { background: rgba(100, 150, 255, 0.6); }

        .search-wrapper { position: fixed; top: 20px; right: 30px; z-index: 50; width: 240px; }
        /* ç§»é™¤ backdrop-filter ä»¥å¤§å¹…æå‡æ¸²æŸ“æ€§èƒ½ */
        #search-container { background: rgba(15, 20, 30, 0.95); border: 1px solid rgba(100, 150, 255, 0.3); border-radius: 20px; padding: 8px 16px; display: flex; align-items: center; transition: all 0.3s; }
        #search-container:focus-within { border-color: rgba(100, 200, 255, 0.9); box-shadow: 0 0 20px rgba(0, 100, 255, 0.3); }
        #search-input { background: transparent; border: none; color: #fff; outline: none; font-size: 14px; width: 100%; margin-left: 8px; font-family: inherit; }
        #search-results { margin-top: 10px; background: rgba(8, 10, 16, 0.95); border: 1px solid rgba(40, 50, 70, 0.8); border-radius: 12px; max-height: 400px; overflow-y: auto; display: none; box-shadow: 0 10px 40px rgba(0,0,0,0.8); }
        #search-results.active { display: block; }
        .search-item { padding: 12px 15px; cursor: pointer; border-bottom: 1px solid rgba(255,255,255,0.05); font-size: 13px; color: #ccc; display: flex; justify-content: space-between; align-items: center; transition: background 0.2s; }
        .search-item:hover, .search-item.selected { background: rgba(30, 100, 200, 0.3); color: #fff; }
        .search-tag { font-size: 11px; color: #88a; background: rgba(255,255,255,0.1); padding: 2px 6px; border-radius: 4px; }

#helicopter-cat { position: fixed; pointer-events: none; z-index: 9999; transform: scale(0.65); transform-origin: top left; width: 32px; height: 24px; top: -100px; left: -100px; transition: transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275); }
#helicopter-cat.excited .propeller { animation-duration: 0.04s; }
        #helicopter-cat.excited .cat-body { box-shadow: 0 0 25px rgba(255, 220, 100, 0.8); background: #fffdf0; }
        .cat-body-container { width: 100%; height: 100%; position: relative; animation: float 2.5s ease-in-out infinite; }
        .cat-body { width: 32px; height: 22px; background: #fff; border-radius: 16px 16px 12px 12px; box-shadow: 0 0 15px rgba(255, 255, 255, 0.5); position: absolute; bottom: 0; display: flex; justify-content: center; align-items: center; transition: all 0.3s; }
        .cat-ear { position: absolute; top: -4px; width: 0; height: 0; border-left: 5px solid transparent; border-right: 5px solid transparent; border-bottom: 10px solid #fff; }
        .cat-ear.left { left: 3px; transform: rotate(-15deg); }
        .cat-ear.right { right: 3px; transform: rotate(15deg); }
        .cat-face { position: absolute; top: 8px; width: 100%; display: flex; justify-content: center; gap: 6px; }
        .eye { width: 3px; height: 3px; background: #333; border-radius: 50%; transition: 0.1s; }
        .eye.closed { height: 1px; transform: scaleX(1.5); background: #555; }
        .propeller { position: absolute; top: -10px; left: 50%; width: 28px; height: 2px; background: rgba(255, 255, 255, 0.9); transform: translateX(-50%); animation: spin 0.08s linear infinite; }
        .propeller::after { content: ''; position: absolute; top: 100%; left: 50%; width: 2px; height: 6px; background: #ccc; transform: translateX(-50%); }
        #zzz-bubble { position: absolute; top: -20px; right: -15px; font-size: 10px; color: #fff; font-weight: bold; opacity: 0; transition: opacity 0.5s; }
        #zzz-bubble.active { opacity: 0.9; animation: floatUp 2s infinite; }
        @keyframes floatUp { 0% { transform: translateY(0); opacity: 0.8; } 100% { transform: translateY(-10px); opacity: 0; } }
        @keyframes spin { 0% { transform: translateX(-50%) rotateY(0deg); } 100% { transform: translateX(-50%) rotateY(360deg); } }
        @keyframes float { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(4px); } }

        #article-modal { display: none; position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background: rgba(5, 5, 8, 0.96); z-index: 1000; opacity: 0; transition: opacity 0.4s ease-out; overflow-y: auto; }
        #article-modal.active { opacity: 1; }
        .article-content { max-width: 800px; margin: 60px auto; padding: 40px; background: rgba(20, 25, 35, 0.4); border: 1px solid rgba(255,255,255,0.1); border-radius: 12px; }
        .close-btn { position: fixed; top: 30px; right: 50px; font-size: 32px; cursor: pointer; color: #888; z-index: 1100; }
        .close-btn:hover { color: #fff; }
        .markdown-body { line-height: 1.7; color: #d0d7de; }
        .markdown-body h1 { border-bottom: 1px solid #30363d; padding-bottom: 0.3em; margin-top: 1.5em; color: #fff; }
        .markdown-body a { color: #58a6ff; text-decoration: none; }
        .markdown-body code { background: rgba(110, 118, 129, 0.4); padding: 0.2em 0.4em; border-radius: 6px; font-family: monospace; }
        .markdown-body pre { background: #161b22; padding: 16px; border-radius: 6px; overflow: auto; }
        .markdown-body img { max-width: 100%; border-radius: 6px; }

        /* Tag Capsule Styles */
        #selected-tags-container {
            margin-top: 8px;
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            width: 100%;
        }
        .tag-capsule {
            background: rgba(100, 200, 255, 0.2);
            border: 1px solid rgba(100, 200, 255, 0.4);
            border-radius: 12px;
            padding: 2px 8px;
            font-size: 11px;
            color: #ade;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 4px;
            transition: all 0.2s;
            user-select: none;
        }
        .tag-capsule:hover {
            background: rgba(100, 200, 255, 0.4);
            color: #fff;
        }
        .tag-capsule .remove-btn {
            font-weight: bold;
            color: rgba(255,255,255,0.6);
            margin-left: 2px;
        }
        .tag-capsule .remove-btn:hover {
            color: #fff;
        }
        
        /* Search Dropdown Tag Style */
        .search-item.type-tag .label-container {
            display: flex;
            align-items: center;
        }
        .search-item.type-tag .tag-capsule-preview {
            background: rgba(100, 200, 255, 0.2);
            border: 1px solid rgba(100, 200, 255, 0.3);
            border-radius: 12px;
            padding: 1px 8px;
            color: #ade;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <div id="3d-graph"></div>
    <div id="helicopter-cat"><div class="cat-body-container"><div id="zzz-bubble">Zzz...</div><div class="propeller"></div><div class="cat-ear left"></div><div class="cat-ear right"></div><div class="cat-body"><div class="cat-face"><div class="eye left"></div><div class="eye right"></div></div></div></div></div>
    
    <!-- Settings Panel (Minimalist - No Background) -->
    <div id="settings-panel" style="position: fixed; bottom: 20px; left: 20px; z-index: 99; padding: 12px; color: #aaa; font-size: 12px; font-family: 'Segoe UI', sans-serif; transition: opacity 0.3s;">
        
        <!-- Controls -->
        <div style="margin-bottom: 15px;">
            <div style="font-weight: bold; color: #fff; margin-bottom: 6px; font-size: 12px; opacity: 0.8;">Controls</div>
            <div style="display: flex; flex-direction: column; gap: 3px;">
                <div><span style="color:#88ccff">Left Mouse</span> &nbsp; Rotate / Drag</div>
                <div><span style="color:#88ccff">Wheel</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Zoom</div>
                <div><span style="color:#88ccff">Right Mouse</span> Rotate</div>
                <div><span style="color:#ffaa00">ESC</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Reset View</div>
            </div>
        </div>

        <!-- View Settings -->
        <div style="margin-bottom: 10px;">
            <div style="font-weight: bold; color: #fff; margin-bottom: 6px; font-size: 12px; opacity: 0.8; border-top: 1px solid rgba(255,255,255,0.1); padding-top: 8px;">Filters</div>
            <div style="display: flex; flex-direction: column; gap: 4px;">
                <div>
                    <input type="checkbox" id="chk-index-nodes" onchange="updateGraphFilter()" style="vertical-align: middle;">
                    <label for="chk-index-nodes" style="vertical-align: middle; cursor: pointer; color: #ccc;">Index Nodes</label>
                </div>
                <div>
                    <input type="checkbox" id="chk-md" checked onchange="updateGraphFilter()" style="vertical-align: middle;">
                    <label for="chk-md" style="vertical-align: middle; cursor: pointer; color: #ccc;">MD Links</label>
                </div>
                <div>
                    <input type="checkbox" id="chk-tag-links" checked onchange="updateGraphFilter()" style="vertical-align: middle;">
                    <label for="chk-tag-links" style="vertical-align: middle; cursor: pointer; color: #ccc;">Tag Links</label>
                </div>
            </div>
        </div>

        <!-- Credits -->
        <div style="margin-top: 12px; border-top: 1px solid rgba(255,255,255,0.1); padding-top: 8px; opacity: 0.6; font-size: 11px;">
            Created by fs
        </div>
    </div>

    <!-- Top Info Bar -->
    <div id="top-info-bar" style="position: fixed; top: 20px; left: 50%; transform: translateX(-50%); z-index: 40; pointer-events: none; opacity: 0; transition: opacity 0.3s; text-align: center; text-shadow: 0 2px 4px rgba(0,0,0,0.8);">
        <div id="info-title" style="font-size: 24px; font-weight: bold; color: #fff; letter-spacing: 1px;"></div>
        <div id="info-tag" style="font-size: 14px; color: #88ccff; margin-top: 4px; font-family: monospace;"></div>
    </div>

    <div class="search-wrapper">
        <div id="search-container">
            <span class="search-icon">ğŸ”</span>
            <input type="text" id="search-input" placeholder="Search universe..." autocomplete="off"/>
        </div>
        <div id="selected-tags-container"></div>
        <div id="search-results"></div>
    </div>
    <div id="article-modal"><div class="close-btn" onclick="closeArticle()">&times;</div><div class="article-content markdown-body" id="markdown-container"></div></div>
    
    <script>
        // å®šä¹‰å…¨å±€å˜é‡å’ŒçŠ¶æ€
        let gData = null; // Store full data globally
        let allTags = new Set(); // Global Tag Registry
        let selectedTags = new Set(); // Current Tag Filter
        let activeLookup = {}; // ç‹¬ç«‹çš„å…¨å±€æŸ¥æ‰¾è¡¨ï¼Œè§£è€¦ Node å¯¹è±¡
        let isNodeDragging = false; // Track node drag state

        // Helper to check if mouse is over search UI
        function isMouseOverSearch() {
            return !!document.querySelector('.search-wrapper:hover');
        }

        // ç»Ÿä¸€çš„é«˜äº®æ¨¡å¼è®¾ç½®å‡½æ•°
        function setHighlightMode(node) {
            hoverNode = node || null; 
            updateCatExcitement(); // è§¦å‘å…¨çŠ¶æ€æ£€æŸ¥
            
            highlightNodes.clear(); highlightLinks.clear();
            
            // Top Info Bar Update
            const infoBar = document.getElementById('top-info-bar');
            if(node) {
                document.getElementById('info-title').innerText = node.label;
                
                let displayTags = '';
                if (node.all_tags && node.all_tags.length > 0) {
                    displayTags = node.all_tags.map(t => `#${t}`).join(' ');
                } else if(node.group) {
                        displayTags = `#${node.group}`;
                }
                document.getElementById('info-tag').innerText = displayTags;
                
                infoBar.style.opacity = 1;
            } else {
                infoBar.style.opacity = 0;
            }
            
            if (node) {
                highlightNodes.add(node);
                
                // ä½¿ç”¨å…¨å±€æŸ¥æ‰¾è¡¨ activeLookup
                const entry = activeLookup[node.id];
                if(entry) {
                    const { nodes } = Graph.graphData();
                    entry.neighbors.forEach(nid => {
                        const neighborNode = nodes.find(n => n.id === nid);
                        if(neighborNode) highlightNodes.add(neighborNode);
                    });
                    entry.links.forEach(l => highlightLinks.add(l));
                }
            }

            // åŠ¨æ€æ›´æ–°ç²’å­æµå‘
            Graph.linkDirectionalParticles(link => (highlightLinks.has(link) && link.type !== 'tag_group') ? 3 : 0);
            Graph.linkDirectionalParticleWidth(link => highlightLinks.has(link) ? 1.5 : 0);
            Graph.linkDirectionalParticleColor(link => link.sourceNode ? link.sourceNode.color : '#ffffff'); 
            Graph.linkDirectionalParticleSpeed(link => 0.005);
        }

        function updateGraphFilter() {
            if(!gData || !Graph) return;
            
            // 1. è·å–æ‰€æœ‰å¼€å…³çŠ¶æ€
            const showMd = document.getElementById('chk-md').checked;
            const showTagLinks = document.getElementById('chk-tag-links') ? document.getElementById('chk-tag-links').checked : true;
            // å…¼å®¹æ£€æŸ¥ç´¢å¼•å¼€å…³
            const chkIndex = document.getElementById('chk-index-nodes');
            const showIndexNodes = chkIndex ? chkIndex.checked : true;
            const indexKeywords = ['index', 'ç›®å½•', 'ç´¢å¼•'];

            // 2. ç­›é€‰èŠ‚ç‚¹ (Nodes)
            let filteredNodes = gData.nodes.filter(n => {
                const nodeTags = (n.all_tags && n.all_tags.length > 0) ? n.all_tags : [n.group || 'default'];
                
                // è¿‡æ»¤ç´¢å¼•èŠ‚ç‚¹
                if (!showIndexNodes) {
                    if (nodeTags.some(tag => indexKeywords.includes(tag.toLowerCase()))) return false;
                }

                // è¿‡æ»¤æ ‡ç­¾ (Tags)
                if (selectedTags.size > 0) {
                    for (let t of selectedTags) {
                         if (!nodeTags.includes(t)) return false;
                    }
                }
                return true;
            });
            const filteredNodeIds = new Set(filteredNodes.map(n => n.id));
            
            // 3. ç­›é€‰é“¾æ¥ (Links)
            let filteredLinks = gData.links.filter(l => {
                const sId = (typeof l.source === 'object') ? l.source.id : l.source;
                const tId = (typeof l.target === 'object') ? l.target.id : l.target;
                
                // ä¸¤ç«¯èŠ‚ç‚¹å¿…é¡»éƒ½åœ¨
                if (!filteredNodeIds.has(sId) || !filteredNodeIds.has(tId)) return false;

                // æ ¹æ®ç±»å‹ç­›é€‰
                if (l.type === 'md') return showMd;
                if (l.type === 'tag_group') return showTagLinks;
                return true; 
            });

            // --- æ ¸å¿ƒï¼šçº¯åŠ¨æ€è‰²æ¸©è®¡ç®— ---

            // A. é‡æ–°ç»Ÿè®¡å½“å‰å¯è§è¿æ¥æ•°
            // Map<NodeID, Count>
            const currentDegrees = new Map();
            filteredNodes.forEach(n => currentDegrees.set(n.id, 0));
            
            const getID = (n) => (typeof n === 'object') ? n.id : n;

            filteredLinks.forEach(link => {

                const sId = getID(link.source);
                const tId = getID(link.target);
                
                if (currentDegrees.has(sId)) currentDegrees.set(sId, currentDegrees.get(sId) + 1);
                if (currentDegrees.has(tId)) currentDegrees.set(tId, currentDegrees.get(tId) + 1);
            });

            // B. æ‰¾å‡ºå½“å‰çš„â€œæœ€é«˜çƒ­åº¦â€ (Dynamic Max Degree)
            let newMaxDegree = 0;
            for (let d of currentDegrees.values()) {
                if (d > newMaxDegree) newMaxDegree = d;
            }
            // ã€ä¿®å¤ã€‘è®¾ç½®ä¸€ä¸ªæœ€ä½é˜ˆå€¼ (æ¯”å¦‚ 10 æˆ– 20)ï¼Œé˜²æ­¢å½“è¿æ¥æ•°æå°‘æ—¶ï¼Œå•ä¸ªèŠ‚ç‚¹çš„å¤§å°æ¯”ä¾‹å¤±æ§çˆ†ç‚¸
            maxDegree = Math.max(newMaxDegree, 20);

            // C. é‡æ–°ä¸Šè‰² (æ ¹æ® degree / maxDegree çš„æ¯”ä¾‹)
            filteredNodes.forEach(node => {
                const degree = currentDegrees.get(node.id) || 0;
                // è¿™é‡Œçš„ getStarColor ä¼šä½¿ç”¨ä¸Šé¢æ›´æ–°è¿‡çš„ maxDegree å…¨å±€å˜é‡
                const newColor = getStarColor(degree);
                
                node.color = newColor; 
                
                // åˆ·æ–° 3D æè´¨
                if (node.__threeObj) {
                    const group = node.__threeObj;
                    
                    // æ ¸å¿ƒ
                    if (group.core) {
                        const newSprite = createCoreSprite(newColor);
                        if(group.core.material.map) group.core.material.map.dispose();
                        group.core.material.map = newSprite.material.map;
                    }
                    // å…‰èŠ’
                    if (group.cross) {
                        const newCross = createCrossSprite(newColor, degree);
                        if(group.cross.material.map) group.cross.material.map.dispose();
                        group.cross.material.map = newCross.material.map;
                    }
                    
                    // åˆ·æ–°å‘¼å¸å¤§å°åŸºå‡† (è®©å¤§èŠ‚ç‚¹å‘¼å¸å¹…åº¦æ›´å¤§)
                    const coreSize = 12;
                    const crossSize = 12 * (1 + (degree / maxDegree) * 0.5);
                    
                    group.userData.baseScaleCore = coreSize;
                    group.userData.baseScaleCross = crossSize;
                }
            });

            // 4. æ›´æ–°å›¾è¡¨æ•°æ®
            Graph.graphData({
                nodes: filteredNodes,
                links: filteredLinks
            });

            // 5. è°ƒæ•´ç‰©ç†å¼•æ“
            Graph.d3Force('charge').strength(-120);

            // 6. é‡å»ºé«˜äº®ç´¢å¼•
            activeLookup = {}; 
            filteredLinks.forEach(link => {
                const sId = getID(link.source);
                const tId = getID(link.target);
                if(!activeLookup[sId]) activeLookup[sId] = { neighbors: [], links: [] };
                if(!activeLookup[tId]) activeLookup[tId] = { neighbors: [], links: [] };
                activeLookup[sId].neighbors.push(tId); activeLookup[sId].links.push(link);
                activeLookup[tId].neighbors.push(sId); activeLookup[tId].links.push(link);
            });
            
            // 7. åˆ·æ–°è¿çº¿é¢œè‰²
            setTimeout(() => {
                const currentLinks = Graph.graphData().links.filter(l => l.type !== 'tag_group');
                currentLinks.forEach(link => {
                    if(link.__lineObj && link.sourceNode && link.targetNode) {
                        const c1 = new THREE.Color(link.sourceNode.color), c2 = new THREE.Color(link.targetNode.color);
                        const attr = link.__lineObj.geometry.attributes.color;
                        attr.setXYZ(0, c1.r, c1.g, c1.b); attr.setXYZ(1, c1.r, c1.g, c1.b);
                        attr.setXYZ(3, c2.r, c2.g, c2.b); attr.setXYZ(4, c2.r, c2.g, c2.b);
                        attr.needsUpdate = true;
                    }
                });
            }, 100);
        }

        // MD é“¾æ¥åŠ«æŒç³»ç»Ÿ
        document.getElementById('markdown-container').addEventListener('click', function(e) {
            if(e.target.tagName === 'A') {
                e.preventDefault();
                const href = e.target.getAttribute('href');
                
                // 1. å°è¯•ä½œä¸ºå†…éƒ¨é“¾æ¥å¤„ç†
                // å»æ‰è·¯å¾„å‰ç¼€ ./posts/ ç­‰ï¼Œä¿ç•™æ–‡ä»¶å
                let targetId = href.split('/').pop(); 
                // å°è¯•åŒ¹é… graph ä¸­çš„ ID (é€šå¸¸æ˜¯ filename.md)
                const { nodes } = Graph.graphData();
                let targetNode = nodes.find(n => n.id === targetId || n.id === targetId + '.md');
                
                // 2. å¦‚æœæ²¡æ‰¾åˆ°ï¼Œå°è¯•æ¨¡ç³ŠåŒ¹é… (æ¯”å¦‚é“¾æ¥å†™çš„æ˜¯ title)
                if(!targetNode) {
                    const cleanRef = decodeURIComponent(targetId).replace(/\.md$/i, '').toLowerCase();
                    targetNode = nodes.find(n => n.label.toLowerCase() === cleanRef || n.id.toLowerCase().includes(cleanRef));
                }

                if(targetNode) {
                    console.log('Jumping to internal link:', targetNode.label);
                    // å…³é—­å½“å‰æ–‡ç« ï¼Œé£è¡Œå¹¶åœ¨é£è¡Œç»“æŸåæ‰“å¼€æ–°æ–‡ç« 
                    // ç¨å¾®ç¼©çŸ­ä¸€ç‚¹é£è¡Œæ—¶é—´ï¼Œä½“éªŒæ›´æµç•…
                    const cam = Graph.camera();
                    const startPos = { x: cam.position.x, y: cam.position.y, z: cam.position.z };
                    
                    // è§†è§‰ä¸Šçš„â€œé£è¶Šâ€
                    closeArticle(); 
                    
                    // é‡æ–°æ‰“å¼€
                    setTimeout(() => {
                         jumpToNode(targetNode.id, true);
                    }, 300); // ç­‰å¾… modal å…³é—­åŠ¨ç”»çš„ä¸€åŠ
                } else {
                    // å¤–éƒ¨é“¾æ¥ï¼Œæ–°æ ‡ç­¾é¡µæ‰“å¼€
                    window.open(href, '_blank');
                }
            }False
        });

        let Graph, maxDegree = 1;
        let highlightNodes = new Set(), highlightLinks = new Set();
        // æ·»åŠ å…¨å±€ skybox å˜é‡ä»¥ä¾¿è·Ÿéš
        let hoverNode = null, initialCameraPos = null, starryParticles = null, skybox = null;
        let selectedNode = null;
        let globalStartPos = null; // å®‡å®™åˆå§‹æœ€ä½³è§†è§’

        // æƒ¯æ€§ç¼©æ”¾ç³»ç»Ÿå˜é‡
        let zoomVelocity = 0;
        let zoomPivot = null;
        let mouseScreenPos = new THREE.Vector2(0, 0);
        let isMouseDown = false; // Track mouse state

        // è‡ªå®šä¹‰é£è¡Œç³»ç»ŸçŠ¶æ€
        const flyState = {
            active: false,
            startPos: new THREE.Vector3(),
            endPos: new THREE.Vector3(),
            startTarget: new THREE.Vector3(),
            endTarget: new THREE.Vector3(),
            startTime: 0,
            duration: 0
        };

        const modal = document.getElementById('article-modal');
        const box = document.getElementById('markdown-container');
        
        // æ ¸å¿ƒäº¤äº’ï¼šæ‰“å¼€æ–‡ç« 
        function openArticle(node) {
            if(!node) return;
            const content = node.content || (node.data && node.data.content) || "# No Content";
            box.innerHTML = marked.parse(content);
            modal.style.display = 'block';
            modal.offsetHeight; // Force reflow
            modal.classList.add('active');
            
            // æ‰“å¼€æ–‡ç« æ—¶ï¼Œè®©çŒ«çŒ«ç¡è§‰ï¼Œé¿å…é®æŒ¡
            const cat = document.getElementById('helicopter-cat');
            if(cat) cat.classList.add('hidden');
        }
        function closeArticle() {
            modal.classList.remove('active');
            setTimeout(() => { modal.style.display = 'none'; }, 400);
            // Camera position reset removed to keep focus on the star
            
            // å”¤é†’çŒ«çŒ«
            const cat = document.getElementById('helicopter-cat');
            if(cat) cat.classList.remove('hidden');
        }
        document.addEventListener('keydown', e => { 
            if(e.key==='Escape') {
                if(modal.classList.contains('active')) {
                    closeArticle();
                } else if(Graph && globalStartPos) {
                    // å›åˆ°å®‡å®™æœ€ä½³è§†è§’(ä½¿ç”¨è‡ªå®šä¹‰é£è¡Œç³»ç»Ÿ)
                    startFly(
                        globalStartPos, 
                        {x:0, y:0, z:0}, 
                        2000
                    );
                }
            }
        });

        // è‰²æ¸©ç®—æ³• (é«˜é¥±å’Œåº¦)
        function getStarColor(degree) {
            const t = Math.pow(degree / maxDegree, 0.7); 
            // Saturation Boosted: Red -> Orange -> Cyan/Blue
            const c1 = new THREE.Color(0xff1133), c2 = new THREE.Color(0xffaa00), c3 = new THREE.Color(0x00ccff);
            if (t < 0.4) return c1.clone().lerp(c2, t * 2.5).getStyle();
            else return c2.clone().lerp(c3, (t - 0.4) * 1.6).getStyle();
        }

        // è§†è§‰ç”Ÿæˆå™¨ 1: æ ¸å¿ƒå…‰çƒ
        function createCoreSprite(color) {
            const canvas = document.createElement('canvas'); canvas.width = 64; canvas.height = 64;
            const ctx = canvas.getContext('2d'); const c = 32;
            const grad = ctx.createRadialGradient(c, c, 2, c, c, 30);
            grad.addColorStop(0, 'rgba(255,255,255,1)'); grad.addColorStop(0.4, color); grad.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle = grad; ctx.beginPath(); ctx.arc(c, c, 30, 0, Math.PI*2); ctx.fill();
            const mat = new THREE.SpriteMaterial({ map: new THREE.CanvasTexture(canvas), transparent: true, blending: THREE.AdditiveBlending, depthWrite: false });
            return new THREE.Sprite(mat);
        }

        // è§†è§‰ç”Ÿæˆå™¨ 2: åå­—å…‰èŠ’
        function createCrossSprite(color, degree) {
            const canvas = document.createElement('canvas'); canvas.width = 256; canvas.height = 256; 
            const ctx = canvas.getContext('2d'); const c = 128;
            ctx.globalCompositeOperation = 'lighter';
            
            // ç¡®ä¿ maxDegree æœ‰å€¼ï¼Œé˜²æ­¢é™¤ä»¥0
            const safeMax = (typeof maxDegree !== 'undefined' && maxDegree > 0) ? maxDegree : 1;
            const rayScale = 0.8 + (degree / safeMax) * 0.5;
            
            const drawRay = (w, h, a) => {
                const g = ctx.createLinearGradient(0, c-h, 0, c+h);
                g.addColorStop(0,'rgba(0,0,0,0)'); g.addColorStop(0.5,`rgba(255,255,255,${a})`); g.addColorStop(1,'rgba(0,0,0,0)');
                ctx.fillStyle = g; ctx.fillRect(c-w/2, c-h, w, h*2);
            };
            drawRay(4, 100*rayScale, 0.9);
            ctx.save(); ctx.translate(c, c); ctx.rotate(Math.PI/2); ctx.translate(-c, -c); 
            drawRay(4, 80*rayScale, 0.9); ctx.restore();
            
            const mat = new THREE.SpriteMaterial({ map: new THREE.CanvasTexture(canvas), transparent: true, blending: THREE.AdditiveBlending, depthWrite: false });
            return new THREE.Sprite(mat);
        }

        // åˆå§‹åŒ–å›¾è¡¨
        Graph = ForceGraph3D()(document.getElementById('3d-graph'))
            // .jsonUrl('./posts_data.json')//æ³¨é‡Šåå¯ä»¥è§£å†³loading...çš„é—®é¢˜
            .showNavInfo(false) // ç¦ç”¨é»˜è®¤çš„åº•éƒ¨å¯¼èˆªæç¤º
            .backgroundColor('rgba(0,0,0,0)') // é€æ˜èƒŒæ™¯ï¼Œä½¿ç”¨ CSS çš„æ·±ç©ºæ¸å˜
            .nodeLabel(null)
            .linkThreeObject(link => {
                const geo = new THREE.BufferGeometry();
                geo.setAttribute('position', new THREE.BufferAttribute(new Float32Array(6), 3));
                
                // é»˜è®¤é¢œè‰² (ç°è‰²)
                let colorArr = [0.5,0.5,0.5, 0.5,0.5,0.5];
                let opacity = 0.15;

                // ç‰¹æ®Šé“¾æ¥æ ·å¼
                if (link.type === 'tag_group') {
                    // Tagé“¾å¼è¿æ¥ï¼šä½¿ç”¨æ·¡è“è‰²ï¼Œä¸”é€æ˜åº¦æ›´ä½ï¼Œæ¨¡æ‹Ÿæ˜Ÿåº§è¿çº¿
                    colorArr = [0.2, 0.4, 0.6, 0.2, 0.4, 0.6]; 
                    opacity = 0.1; 
                }

                geo.setAttribute('color', new THREE.BufferAttribute(new Float32Array(colorArr), 3));
                // åå‘é“¾æ¥å®Œå…¨é€æ˜ï¼Œä¸å¹²æ‰°è§†è§‰ï¼Œåªæä¾›ç²’å­è·¯å¾„
                if (link.isReverse) opacity = 0;
                
                const mat = new THREE.LineBasicMaterial({ vertexColors: true, transparent: true, opacity: opacity });
                const line = new THREE.Line(geo, mat); 
                line.frustumCulled = false; // å…³é”®ä¿®å¤ï¼šé˜²æ­¢è¿‘è·ç¦»è§‚å¯Ÿæ—¶è¿çº¿å› è§†é”¥ä½“è¯¯åˆ¤è€Œæ¶ˆå¤±
                link.__lineObj = line; return line;
            })
            .linkPositionUpdate((line, { start, end }) => {
                const p = line.geometry.attributes.position.array;
                p[0]=start.x; p[1]=start.y; p[2]=start.z; p[3]=end.x; p[4]=end.y; p[5]=end.z;
                line.geometry.attributes.position.needsUpdate = true; return true; 
            })
            .nodeThreeObject(node => {
                const degree = (node.neighbors && node.neighbors.length) || 0;
                let color = getStarColor(degree); node.color = color; 
                const group = new THREE.Group();
                
                // 1. æ ¸å¿ƒçƒä½“
                const core = createCoreSprite(color);
                const coreSize = 12; 
                core.scale.set(coreSize, coreSize, 1);
                group.add(core); group.core = core;

                // 2. åå­—å…‰èŠ’ (ç‹¬ç«‹ï¼Œä»¥ä¾¿åŠ¨æ€ç¼©æ”¾)
                const cross = createCrossSprite(color, degree);
                const crossSize = 12 * (1 + (degree/maxDegree)*0.5);
                cross.scale.set(crossSize, crossSize, 1);
                group.add(cross); group.cross = cross;

                // å…±äº«çŠ¶æ€
                group.userData = { 
                    phase: Math.random()*Math.PI*2, 
                    baseScaleCore: coreSize,
                    baseScaleCross: crossSize,
                    currentOpacity: 1.0, 
                    speed: 0.5+Math.random() 
                };
                
                // æ ‡é¢˜ (ç™½è‰²)
                const text = new SpriteText(node.label); 
                text.color = '#fff'; text.textHeight = 4; 
                // Fix: ä½¿ç”¨ center å±æ€§ä»£æ›¿ position.yï¼Œç¡®ä¿æ–‡å­—å§‹ç»ˆåœ¨å¹¶åœ¨å±å¹•ç©ºé—´ä¸‹æ–¹
                // (0.5, 4.0) means anchor is horizontal-center and vertical-offset (pushed up relative to text)
                text.center = new THREE.Vector2(0.5, 4.0);
                text.material.transparent = true; text.material.opacity = 0; text.material.depthWrite = false;
                group.add(text); group.text = text; 
                
                // Tag æ ‡ç­¾ (ç°è‰²ï¼Œå°å­—ä½“ï¼Œæ˜¾ç¤ºæ‰€æœ‰Tags)
                // ä¼˜å…ˆä½¿ç”¨ all_tags æ•°ç»„ï¼Œå¦‚æœæ²¡æœ‰åˆ™å›é€€åˆ° group
                let tagStr = '';
                if (node.all_tags && node.all_tags.length > 0) {
                    tagStr = node.all_tags.map(t => `#${t}`).join(' ');
                } else if (node.group && node.group !== 'default') {
                    tagStr = `#${node.group}`;
                }
                
                const subText = new SpriteText(tagStr);
                subText.color = '#88a'; subText.textHeight = 2.5;
                // Tag ç´§éšæ ‡é¢˜ä¸‹æ–¹
                subText.center = new THREE.Vector2(0.5, 8.0);
                subText.material.transparent = true; subText.material.opacity = 0; subText.material.depthWrite = false;
                group.add(subText); group.subText = subText;

                return group;
            })
            .onNodeHover(node => {
                if(modal.classList.contains('active')) return;
                if(isMouseOverSearch()) return; // Ignore canvas hover if interacting with search UI

                if (node) {
                    setHighlightMode(node);
                } else {
                    // Fallback to selectedNode if exists (persist highlight)
                    if (selectedNode) {
                        setHighlightMode(selectedNode);
                        document.body.style.cursor = 'default'; // Correct cursor for background
                    } else {
                        setHighlightMode(null);
                    }
                }
            })
            .onNodeDrag(() => { isNodeDragging = true; })
            .onNodeDragEnd(() => { isNodeDragging = false; })
            .onNodeClick(node => {
                if(!node) return;
                
                // Check view status BEFORE updating selection (to determine action)
                // é”å®šåˆ¤æ–­é€»è¾‘ï¼šéœ€è¦åŒæ—¶æ»¡è¶³ 1.å·²é€‰ä¸­ 2.è·ç¦»åˆé€‚ 3.è§†è§’å±…ä¸­
                const isSelected = (selectedNode && selectedNode.id === node.id);
                
                const cam = Graph.camera();
                const nodePos = new THREE.Vector3(node.x, node.y, node.z);
                const camPos = new THREE.Vector3(cam.position.x, cam.position.y, cam.position.z);
                
                // 1. Distance Check
                const dist = camPos.distanceTo(nodePos);
                const isDistOk = Math.abs(dist - 300) < 40; // Allow slight tolerance around 300 (280-340)
                
                // 2. Centered Check (Angle)
                const viewDir = new THREE.Vector3();
                cam.getWorldDirection(viewDir); // Camera look direction
                const toNodeDir = nodePos.clone().sub(camPos).normalize();
                const angle = viewDir.angleTo(toNodeDir);
                const isCentered = angle < 0.15; // Approx 8.5 degrees tolerance

                // Always activate visual selection first
                selectedNode = node;
                setHighlightMode(node);

                if (isSelected && isDistOk && isCentered) {
                    openArticle(node);
                } else {
                    // Focus Mode: Pull back/Center
                    flyTo(node, 1200);
                }
            })
            .onBackgroundClick(() => {
                selectedNode = null;
                setHighlightMode(null); // Clear highlight manually
                // Close search if active
                const sr = document.getElementById('search-results');
                if (sr.classList.contains('active')) {
                    sr.classList.remove('active');
                    document.getElementById('search-input').blur();
                }
            });

        // æ•°æ®å¤„ç†
        fetch('./posts_data.json').then(r => r.json()).then(data => {
            const map = {};
            allTags.clear();

            // 1. å»ºç«‹ç´¢å¼• & æ”¶é›†æ‰€æœ‰ Tag (ç”¨äºæœç´¢)
            data.nodes.forEach(n => { 
                n.neighbors = []; 
                map[n.id] = n; 
                
                // ä»…æ”¶é›† Tag ä¾›æœç´¢ä½¿ç”¨ï¼Œä¸å†è¿›è¡Œå‰ç«¯èšç±»è®¡ç®—
                const tagsToProcess = (n.all_tags && n.all_tags.length > 0) ? n.all_tags : [n.group || 'default'];
                tagsToProcess.forEach(tag => allTags.add(tag));
            });

            // 2. å¤„ç†å®ä½“é“¾æ¥ & é¢„å¤„ç† (MD Link & Tag Link)
            // æ­¤æ—¶ data.links å·²ç»åŒ…å«åç«¯ç”Ÿæˆçš„ type: 'tag_group' é“¾æ¥
            data.links.forEach(l => {
                // é»˜è®¤ç±»å‹å½’ä¸º md (å¦‚æœåç«¯æœªæŒ‡å®š) -- è™½ç„¶ç›®å‰åç«¯éƒ½æŒ‡å®šäº†
                if(!l.type) l.type = 'md';
            });

            data.links.forEach(l => {
                // Pre-resolve objects for ForceGraph
                const a = map[l.source], b = map[l.target];
                if(a && b) { 
                    // æ‰€æœ‰ MD å’Œ Tag é“¾æ¥éƒ½å‚ä¸é‚»å±…ç»Ÿè®¡
                    a.neighbors.push(b); 
                    b.neighbors.push(a);
                    l.sourceNode = a; l.targetNode = b; 
                }
            });

            maxDegree = 0; data.nodes.forEach(n => { if(n.neighbors.length > maxDegree) maxDegree = n.neighbors.length; });
            if(maxDegree < 1) maxDegree = 1;

            // Save to Global
            gData = data;

            // Initialize Layout via Filter function
            // 4. å®šåˆ¶èšç±»åŠ›
            Graph.d3Force('charge').strength(-120); 
            // é’ˆå¯¹ Tag ç»„è¿æ¥ (é“¾å¼) è®¾ç½®è¾ƒå¼±çš„æ‹‰åŠ›ï¼Œé¿å…å›¾è°±è¿‡äºåƒµç¡¬
            Graph.d3Force('link')
                .distance(link => link.type === 'tag_group' ? 40 : 100)
                .strength(link => link.type === 'tag_group' ? 0.05 : 1);
            
            // 5. è‡ªå®šä¹‰é¼ æ ‡ç¼©æ”¾ (Zoom to Cursor) & äº¤äº’é™åˆ¶
            Graph.enableNodeDrag(true); // æ¢å¤å·¦é”®æ‹–åŠ¨æ˜Ÿæ˜Ÿ
            
            const controls = Graph.controls();
            controls.enablePan = false;  // ç¦ç”¨å³é”®å¹³ç§»ï¼Œé˜²æ­¢è¿·å¤±
            controls.enableZoom = false; // ç¦ç”¨åŸç”Ÿç¼©æ”¾ï¼Œæ¥ç®¡æ»šè½®
            
            // é™åˆ¶ç›¸æœºæ´»åŠ¨èŒƒå›´ (å‚è€ƒ Far=8000)
            controls.minDistance = 50;   // æœ€è¿‘èƒ½çœ‹å¤šè¿‘
            controls.maxDistance = 7000; // æœ€è¿œèƒ½æ‹‰å¤šè¿œ (é™åˆ¶åœ¨çƒä½“å†…)

            // è®°å½•åˆå§‹æœ€ä½³è§†è§’
            setTimeout(() => {
                const c = Graph.camera().position;
                globalStartPos = { x: c.x, y: c.y, z: c.z };
            }, 1000);

            // è®°å½•é¼ æ ‡ä½ç½®ä¾›åŠ¨ç”»å¸§ä½¿ç”¨
            document.addEventListener('mousemove', (e) => {
                mouseScreenPos.x = (e.clientX / window.innerWidth) * 2 - 1;
                mouseScreenPos.y = -(e.clientY / window.innerHeight) * 2 + 1;
            });

            // è¾…åŠ©å‡½æ•°ï¼šç”¨æˆ·äº¤äº’æ—¶ç«‹å³åœæ­¢ç›¸æœºè‡ªåŠ¨é£è¡Œï¼Œé˜²æ­¢å†²çªå¡é¡¿
            function stopCameraAnimation() {
                // æ ¸å¿ƒä¿®å¤ï¼šç«‹å³æ‰‹åŠ¨ç»ˆæ­¢è‡ªå®šä¹‰é£è¡Œå¾ªç¯
                flyState.active = false;
                
                // å¼ºåˆ¶æ¸…é›¶æƒ¯æ€§ç¼©æ”¾
                zoomVelocity = 0;
                
                if (!Graph) return;

                // 1. è·å–å½“å‰çŠ¶æ€
                const cam = Graph.camera();
                const controls = Graph.controls();
                
                // 2. åœæ­¢ ForceGraph å†…éƒ¨å¯èƒ½å­˜åœ¨çš„ä»»ä½•è¿‡æ¸¡
                // åŸç†ï¼šå°†ç›¸æœºç›®æ ‡è®¾ä¸º"å½“å‰ä½ç½®"ï¼Œæ—¶é—´è®¾ä¸º0ï¼Œå¼ºè¡Œç»“æŸä¹‹å‰çš„ Tween
                const currentPos = cam.position.clone();
                const currentTarget = controls.target.clone();
                
                Graph.cameraPosition(
                    { x: currentPos.x, y: currentPos.y, z: currentPos.z },
                    { x: currentTarget.x, y: currentTarget.y, z: currentTarget.z },
                    0
                );
                
                // 3. å¼ºåˆ¶ Controls åŒæ­¥ï¼Œé˜²æ­¢è¿™ä¸€å¸§å‡ºç°è·³å˜
                controls.update();
            }

            // ç›‘å¬äº¤äº’äº‹ä»¶ä»¥æ‰“æ–­è‡ªåŠ¨é£è¡Œ
            const graphEl = document.getElementById('3d-graph');
            // æ³¨æ„ï¼šä½¿ç”¨ Capture æ•è·æ¨¡å¼ï¼Œç¡®ä¿åœ¨ OrbitControls å“åº”ä¹‹å‰å°±åœæ­¢åŠ¨ç”»
            graphEl.addEventListener('mousedown', (e) => { isMouseDown = true; stopCameraAnimation(); }, true);
            graphEl.addEventListener('mouseup', () => { isMouseDown = false; }, true);
            graphEl.addEventListener('touchstart', stopCameraAnimation, { passive: true, capture: true });

            document.addEventListener('wheel', (e) => {
                if(modal.classList.contains('active') || e.target.closest('.search-wrapper')) return;
                
                stopCameraAnimation(); // æ»šè½®ä»‹å…¥ä¼˜å…ˆæƒæœ€é«˜
                
                e.preventDefault();
                // ç´¯åŠ åŠ¨åŠ›ï¼Œè€Œä¸æ˜¯ç›´æ¥ä½ç§»
                // æ–¹å‘ä¿®æ­£ï¼šdeltaY > 0 æ˜¯å‘ä¸‹æ»š(æ‹‰è¿‘/æ‹‰è¿œå–å†³äºä¹ æƒ¯)ï¼Œé€šå¸¸æ»šè½®å‘ä¸‹æ˜¯Viewå˜å¤§(ç¦»å¾—æ›´è¿œ)
                // è¿™é‡Œè®¾å®šï¼šæ»šè½®å‘ä¸‹(æ­£) -> è¿œç¦» -> Velocity > 0
                const sensitivity = 0.0008; 
                zoomVelocity += e.deltaY * sensitivity;
            }, { passive: false });

            updateGraphFilter(); // Initial Render
        });

        // åŠ¨ç”»å¾ªç¯
        function animateFrame() {
            requestAnimationFrame(animateFrame);
            
            // 0. å¤©ç©ºç›’ä½ç½®é”å®š (æ ¸å¿ƒä¿®å¤ï¼šé˜²æ­¢æ‹‰è¿œç©¿å¸®)
            // è®©å¤©ç©ºçƒæ°¸è¿œè·Ÿéšç€ç›¸æœºç§»åŠ¨ï¼Œä»è€Œè¾¾åˆ°"æ— é™å¤§"çš„é”™è§‰
            if (skybox && Graph.camera()) {
                skybox.position.copy(Graph.camera().position);
            }

            // 1. å¤„ç†è‡ªå®šä¹‰å¹³æ»‘é£è¡Œ
            if (flyState.active) {
                const now = Date.now();
                const elapsed = now - flyState.startTime;
                
                if (elapsed >= flyState.duration) {
                    flyState.active = false;
                    // Ensure final state
                    Graph.camera().position.copy(flyState.endPos);
                    Graph.controls().target.copy(flyState.endTarget);
                    Graph.controls().update();
                } else {
                    const progress = easeInOutCubic(elapsed / flyState.duration);
                    
                    // Lerp Position
                    const newPos = new THREE.Vector3().lerpVectors(flyState.startPos, flyState.endPos, progress);
                    Graph.camera().position.copy(newPos);
                    
                    // Lerp Target (LookAt)
                    const newTarget = new THREE.Vector3().lerpVectors(flyState.startTarget, flyState.endTarget, progress);
                    Graph.controls().target.copy(newTarget);
                    
                    Graph.controls().update();
                }
            }
            
            // A. å¤„ç†æƒ¯æ€§ç¼©æ”¾
            if (Math.abs(zoomVelocity) > 0.0001) {
                const cam = Graph.camera();
                const target = Graph.controls().target;

                // 1. å®æ—¶è®¡ç®—å½“å‰é”šç‚¹ (Real-time pivot)
                let currentPivot = null;
                
                if (hoverNode) {
                    currentPivot = new THREE.Vector3(hoverNode.x, hoverNode.y, hoverNode.z);
                } else {
                    const raycaster = new THREE.Raycaster();
                    raycaster.setFromCamera(mouseScreenPos, cam);
                    const planeNormal = new THREE.Vector3();
                    cam.getWorldDirection(planeNormal);
                    const planeAtTarget = new THREE.Plane().setFromNormalAndCoplanarPoint(planeNormal, target);
                    const intersect = new THREE.Vector3();
                    raycaster.ray.intersectPlane(planeAtTarget, intersect);
                    if(intersect) currentPivot = intersect;
                }

                if (currentPivot) {
                    // 2. åº”ç”¨ç¼©æ”¾ (æ— é™åˆ¶ç‰ˆ)
                    const factor = 1 + zoomVelocity;
                    
                    const camVec = cam.position.clone().sub(currentPivot).multiplyScalar(factor);
                    const tgtVec = target.clone().sub(currentPivot).multiplyScalar(factor);
                    
                    const nextPos = currentPivot.clone().add(camVec);
                    const nextTarget = currentPivot.clone().add(tgtVec);
                    
                    // å¢åŠ è¾¹ç•Œé™åˆ¶ï¼šä»…å½“æ–°ä½ç½®åœ¨å…è®¸åŠå¾„å†…æ—¶æ‰åº”ç”¨
                    // å‚è€ƒ controls.maxDistance (7000)
                    if (nextPos.length() < 7000 && nextPos.length() > 50) {
                        cam.position.copy(nextPos);
                        target.copy(nextTarget);
                        Graph.controls().update();
                    }
                }

                // 3. é˜»å°¼è¡°å‡
                zoomVelocity *= 0.85; 
                if (Math.abs(zoomVelocity) < 0.0001) {
                    zoomVelocity = 0;
                }
            }

            const { nodes, links } = Graph.graphData();
            if(!nodes || nodes.length === 0) return;
            
            const camPos = Graph.camera().position;
            const camDist = Math.hypot(camPos.x, camPos.y, camPos.z);
            const time = Date.now() * 0.002;
            const isHovering = (hoverNode !== null);

            // ç²’å­ç³»ç»ŸShaderæ¥ç®¡äº†èƒŒæ™¯æ¶ˆéšï¼Œæ­¤å¤„ä»…å¤„ç†Graphé€»è¾‘

            const isModalOpen = modal.classList.contains('active');

            nodes.forEach(node => {
                const group = node.__threeObj; if (!group) return;
                const dist = Math.hypot(node.x-camPos.x, node.y-camPos.y, node.z-camPos.z);
                
                // æ ‡é¢˜ & Tag LOD (æ–‡ç« æ‰“å¼€æ—¶å¼ºåˆ¶éšè—)
                let textOp = 0;
                if(!isModalOpen) {
                    if(isHovering) { if(highlightNodes.has(node)) textOp = 1; }
                    // å¢åŠ å¯è§†è·ç¦»ï¼šä» 200 æå‡åˆ° 500ï¼Œä¸”è¡°å‡æ›´å¹³ç¼“
                    else { 
                        if(dist < 500) textOp = 1 - (dist - 150)/350; 
                    }
                    if(textOp<0)textOp=0; if(textOp>1)textOp=1;
                }
                // å¹³æ»‘è¿‡æ¸¡
                group.text.material.opacity += (textOp - group.text.material.opacity) * 0.15;
                // Tagæ¯”æ ‡é¢˜ç¨å¾®æ·¡ä¸€ç‚¹ï¼Œæˆ–è€…åŒæ­¥
                group.subText.material.opacity = group.text.material.opacity * 0.7;
                
                // æœ¬ä½“æ¶ˆéš
                let targetOp = (isHovering && !highlightNodes.has(node)) ? 0.1 : 1.0;
                group.userData.currentOpacity += (targetOp - group.userData.currentOpacity) * 0.1;
                const op = group.userData.currentOpacity;
                
                // åº”ç”¨é€æ˜åº¦
                group.core.material.opacity = op;
                group.cross.material.opacity = op;
                
                // å‘¼å¸ & åŠ¨æ€ç¼©æ”¾
                if(op > 0.5) {
                    const timeS = Math.sin(time * group.userData.speed + group.userData.phase);
                    
                    // 1. Core: ä»…å‘¼å¸
                    const sCore = 1 + timeS * 0.08;
                    const bCore = group.userData.baseScaleCore;
                    group.core.scale.set(bCore*sCore, bCore*sCore, 1);
                    
                    // 2. Cross: å‘¼å¸ + é€‚åº¦è·ç¦»è¡¥å¿
                    // è°ƒæ•´ä¸ºæœ€å¤§æ”¾å¤§ 5 å€ï¼Œä¸”å¢é•¿æ›²çº¿æ›´å¹³ç¼“ (dist/300)
                    // è¿™æ ·è¿œå¤„çš„æ˜Ÿæ˜Ÿåå­—ä¸ä¼šæ˜¾å¾—å–§å®¾å¤ºä¸»
                    const distFactor = 1 + Math.min(dist / 300, 5.0); 
                    
                    const sCross = sCore * distFactor;
                    const bCross = group.userData.baseScaleCross;
                    group.cross.scale.set(bCross*sCross, bCross*sCross, 1);
                }
            });
            
            links.forEach(link => {
                const line = link.__lineObj; if(!line) return;
                let t = 0.3;
                if(isHovering) t = highlightLinks.has(link) ? 0.8 : 0.02;
                line.material.opacity += (t - line.material.opacity) * 0.1;
            });
        }
        animateFrame();

        // æœç´¢ç³»ç»Ÿ
        const searchInput = document.getElementById('search-input');
        const searchResults = document.getElementById('search-results');

        // Global click to close search from anywhere
        document.addEventListener('click', (e) => {
            const wrapper = document.querySelector('.search-wrapper');
            if (searchResults.classList.contains('active') && !wrapper.contains(e.target)) {
                searchResults.classList.remove('active');
                searchInput.blur();
            }
        });

        let searchIndex = -1;

        // æ ¸å¿ƒé£è¡Œå‡½æ•°
        function startFly(endPos, endTarget, duration = 1500) {
            if (!Graph) return;
            const cam = Graph.camera();
            const controls = Graph.controls();

            flyState.startPos.copy(cam.position);
            flyState.startTarget.copy(controls.target);
            
            // Handle raw object input for endPos
            if (endPos.x !== undefined) flyState.endPos.set(endPos.x, endPos.y, endPos.z);
            else flyState.endPos.copy(endPos);

            // Handle raw object input for endTarget
            if (endTarget.x !== undefined) flyState.endTarget.set(endTarget.x, endTarget.y, endTarget.z);
            else flyState.endTarget.copy(endTarget);
            
            flyState.startTime = Date.now();
            flyState.duration = duration;
            flyState.active = true;
        }

        // Cubic Ease InOut
        function easeInOutCubic(t) {
            return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
        }

        function flyTo(node, duration = 1500) {
            const cam = Graph.camera();
            const nodePos = new THREE.Vector3(node.x, node.y, node.z);
            const camPos = new THREE.Vector3(cam.position.x, cam.position.y, cam.position.z);
            
            // Desired direction
            let dir = new THREE.Vector3().subVectors(camPos, nodePos).normalize();
            if (dir.lengthSq() < 0.001) dir.set(0, 0, 1);
            
            const dist = 300;
            const targetPos = nodePos.clone().add(dir.multiplyScalar(dist));
            
            // Start custom flight
            startFly(targetPos, nodePos, duration);
        }

        function jumpToNode(id, openDoc = false) {
            const { nodes } = Graph.graphData();
            const node = nodes.find(n => n.id === id);
            if(node) {
                selectedNode = node; 
                
                // æ‰§è¡Œå¹³æ»‘é£è¡Œ
                flyTo(node, 1200);
                
                // Highlight Mode
                setHighlightMode(node);
                
                if(openDoc) {
                    setTimeout(() => openArticle(node), 1200);
                    searchInput.value = ''; searchResults.classList.remove('active');
                }
            }
        }

        // Tag Mangement System
        function toggleTag(tagName) {
            if (selectedTags.has(tagName)) {
                selectedTags.delete(tagName);
            } else {
                selectedTags.add(tagName);
            }
            renderSelectedTags();
            updateGraphFilter();
            searchInput.value = ''; 
            searchResults.classList.remove('active');
            searchInput.focus();
        }

        function removeTag(tagName) {
            selectedTags.delete(tagName);
            renderSelectedTags();
            updateGraphFilter();
        }

        function renderSelectedTags() {
            const container = document.getElementById('selected-tags-container');
            container.innerHTML = Array.from(selectedTags).map(tag => `
                <div class="tag-capsule" onclick="removeTag('${tag}')">
                    <span>#${tag}</span>
                    <span class="remove-btn">&times;</span>
                </div>
            `).join('');
        }

        searchInput.addEventListener('input', (e) => {
            const val = e.target.value.toLowerCase().trim();
            if(!val) { searchResults.classList.remove('active'); return; }
            
            // 1. Search Tags
            const validTags = Array.from(allTags).filter(t => 
                t.toLowerCase().includes(val) && !selectedTags.has(t)
            ).map(t => ({ type: 'tag', label: t, id: `TAG_${t}`, score: 30 })); // High priority for tags

            // 2. Search Nodes (Only in current graph view)
            const nodeMatches = Graph.graphData().nodes.map(n => {
                let score = 0, l = (n.label||'').toLowerCase(), i = (n.id||'').toLowerCase();
                if(l===val) score+=20; else if(l.startsWith(val)) score+=10; else if(l.includes(val)) score+=5;
                if(i.includes(val)) score+=10; // Increased weight for filename match
                return { type: 'node', n, score, id: n.id };
            }).filter(o => o.score>0);

            // Merge & Sort
            const allMatches = [...validTags, ...nodeMatches].sort((a,b)=>b.score-a.score).slice(0, 10);

            if(allMatches.length > 0) {
                searchResults.innerHTML = allMatches.map((m, idx) => {
                    if (m.type === 'tag') {
                        return `
                        <div class="search-item type-tag" data-type="tag" data-val="${m.label}" data-idx="${idx}">
                            <div class="label-container">
                                <span class="tag-capsule-preview">#${m.label}</span>
                            </div>
                            <span class="search-tag-indicator">Tag Filter</span>
                        </div>`;
                    } else {
                        return `
                        <div class="search-item type-node" data-type="node" data-id="${m.n.id}" data-idx="${idx}">
                            <span class="label">${m.n.label}</span>
                            <span class="search-tag" style="font-family: monospace; opacity: 0.6;">${m.n.id}</span>
                        </div>`;
                    }
                }).join('');
                searchResults.classList.add('active');
                
                document.querySelectorAll('.search-item').forEach(el => {
                    el.addEventListener('mouseenter', () => { // Hover Preview
                        searchIndex = parseInt(el.dataset.idx);
                        updateSelection();
                        // Only jump if it's a node
                        if (el.dataset.type === 'node') {
                             jumpToNode(el.dataset.id, false); 
                        }
                    });
                    el.addEventListener('click', () => {
                        if (el.dataset.type === 'tag') {
                            toggleTag(el.dataset.val);
                        } else {
                            jumpToNode(el.dataset.id, true);
                        }
                    }); // Click Confirm
                });
            } else searchResults.classList.remove('active');
            searchIndex = -1;
        });

        searchInput.addEventListener('keydown', (e) => {
            const items = document.querySelectorAll('.search-item');
            if(!searchResults.classList.contains('active')) return;
            if(e.key === 'ArrowDown' || e.key === 'ArrowUp') {
                e.preventDefault();
                searchIndex = (e.key === 'ArrowDown') ? (searchIndex+1)%items.length : (searchIndex-1+items.length)%items.length;
                updateSelection();
                // Preview logic on arrow keys
                if(items[searchIndex] && items[searchIndex].dataset.type === 'node') {
                    jumpToNode(items[searchIndex].dataset.id, false);
                }
            } else if(e.key === 'Enter') {
                e.preventDefault();
                const target = searchIndex >= 0 ? items[searchIndex] : items[0];
                if(target) {
                    if (target.dataset.type === 'tag') {
                        toggleTag(target.dataset.val);
                    } else {
                        jumpToNode(target.dataset.id, true);
                    }
                }
            }
        });
        function updateSelection() {
            const items = document.querySelectorAll('.search-item');
            items.forEach(el => el.classList.remove('selected'));
            if(items[searchIndex]) { items[searchIndex].classList.add('selected'); items[searchIndex].scrollIntoView({block:'nearest'}); }
        }

        // Prevent graph rotation when hovering search
        const searchWrapper = document.querySelector('.search-wrapper');
        searchWrapper.addEventListener('mouseenter', () => {
            if(Graph && Graph.controls()) Graph.controls().enabled = false;
        });
        searchWrapper.addEventListener('mouseleave', () => {
             if(Graph && Graph.controls()) Graph.controls().enabled = true;
        });
        // Failsafe: Ensure controls are enabled if mouse is not over search (e.g. after layout change)
        document.addEventListener('mousemove', (e) => {
             // Only interfere if we are NOT dragging a node. 
             // If dragging, let the library manage controls (it disables them).
             if(Graph && Graph.controls() && !isNodeDragging) {
                 const isOver = e.target.closest('.search-wrapper');
                 if(isOver) {
                     Graph.controls().enabled = false;
                 } else {
                     Graph.controls().enabled = true;
                 }
             }
        });

        // èƒŒæ™¯æ˜Ÿç©º (å®‰å…¨è§†è·ä¼˜åŒ–ç‰ˆ)
        setTimeout(() => {
            if(Graph.camera()) {
                // è®¾ç½®åˆç†çš„è¿œè£åˆ‡é¢ (Skybox R=4000, Stars R=4000, Far=8000 è¶³å¤Ÿå®‰å…¨)
                // ä¹‹å‰ Far=30000 ä¸” Skybox=30000 å®¹æ˜“å¯¼è‡´ Z-fighting æˆ–è¢«åˆ‡é™¤é—ªçƒ
                Graph.camera().far = 16000;
                Graph.camera().updateProjectionMatrix();
            }

            const geo = new THREE.BufferGeometry();
            const pos = [], cols = [];
            
            // å°†æ˜Ÿæ˜ŸèŒƒå›´å‹ç¼©åˆ° 600 -> 3500ï¼Œç¡®ä¿åœ¨è§†é”¥ä½“å†…
            for(let i=0; i<8000; i++) {
                const r = 3000 * Math.pow(Math.random(), 0.5) + 600; 
                const theta = Math.random()*Math.PI*2, phi = Math.acos(2*Math.random()-1);
                pos.push(r*Math.sin(phi)*Math.cos(theta), r*Math.sin(phi)*Math.sin(theta), r*Math.cos(phi));
                
                const c = new THREE.Color().setHSL(0.6, 0.2, 0.7 + Math.random() * 0.3); 
                cols.push(c.r, c.g, c.b);
            }
            geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
            geo.setAttribute('color', new THREE.Float32BufferAttribute(cols, 3));

            // ç®€åŒ– Shader é€»è¾‘ï¼Œä»…ä½¿ç”¨æ ‡å‡†æè´¨é…åˆçº¹ç†ï¼Œæ€§èƒ½æ›´å¥½
            // æ‰‹ç»˜ä¸€ä¸ªåœ†å½¢å…‰æ™•çº¹ç†ï¼Œä¸ç”¨ shader åŠ¨æ€ç®—
            const canvas = document.createElement('canvas'); canvas.width = 32; canvas.height = 32;
            const ctx = canvas.getContext('2d');
            const g = ctx.createRadialGradient(16,16,0,16,16,16);
            g.addColorStop(0, 'rgba(255,255,255,1)'); g.addColorStop(1, 'rgba(255,255,255,0)');
            ctx.fillStyle = g; ctx.fillRect(0,0,32,32);
            
            const tex = new THREE.CanvasTexture(canvas);

            const mat = new THREE.PointsMaterial({
                size: 4, // ç¨å¾®è°ƒå°ä¸€ç‚¹ï¼Œæ˜¾å¾—æ›´è¿œ
                map: tex,
                vertexColors: true,
                transparent: true,
                opacity: 0.8, // æé«˜ä¸é€æ˜åº¦ï¼Œè®©æ—‹è½¬æ—¶çš„è§†å·®æ›´æ˜æ˜¾
                sizeAttenuation: true,
                depthWrite: false,
                blending: THREE.AdditiveBlending
            });
            
            starryParticles = new THREE.Points(geo, mat);
            starryParticles.renderOrder = 10; // æ˜Ÿæ˜Ÿåœ¨å¤©ç©ºçƒä¹‹å‰æ¸²æŸ“
            Graph.scene().add(starryParticles);

            // --- æç®€æ·±ç©ºèƒŒæ™¯ (æ— é™è¿œå¤©ç©ºç›’) ---
            const skyMat = new THREE.ShaderMaterial({
                side: THREE.BackSide, 
                depthWrite: false, // ä¸å†™å…¥æ·±åº¦ï¼Œæ°¸è¿œåœ¨èƒŒæ™¯
                // æ— é™è¿œæŠ€æœ¯æ ¸å¿ƒï¼š
                // 1. gl_Position.z = gl_Position.w å¼ºåˆ¶æ¨åˆ°è¿œè£å‰ªé¢
                // 2. åªéœ€è¦æ–¹å‘ï¼Œä¸éœ€è¦å®é™…è·ç¦»
                vertexShader: `
                    varying vec3 vP; 
                    void main(){ 
                        vP = position; 
                        vec4 pos = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                        // å¼ºåˆ¶ Z æ·±åº¦ä¸ºæœ€å¤§å€¼ (w)ï¼Œç¡®ä¿æ¸²æŸ“åœ¨æ‰€æœ‰ç‰©ä½“ä¹‹å
                        gl_Position = pos.xyww;
                    }
                `,
                fragmentShader: `
                    varying vec3 vP;
                    // ç®€å•çš„ä¼ªéšæœºæŠ–åŠ¨å‡½æ•°
                    float random(vec2 st) { return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123); }

                    void main() {
                        vec3 d = normalize(vP);
                        
                        // 1. åŸºåº•
                        vec3 c = vec3(0.03, 0.03, 0.05); 
                        
                        // 2. å¹¿åŸŸè“è‰²æµ
                        float g1 = (d.y + 1.0) * 0.5; 
                        // ä½¿ç”¨ cubic å¹³æ»‘æ’å€¼è€Œéçº¿æ€§æ’å€¼ï¼Œå‡å°‘æ¡å¸¦æ„Ÿ
                        g1 = g1 * g1 * (3.0 - 2.0 * g1);
                        c += vec3(0.02, 0.04, 0.12) * g1; 
                        
                        // 3. å¹¿åŸŸç´«è‰²æµ
                        float g2 = (dot(d, normalize(vec3(1.0, 0.2, -0.5))) + 1.0) * 0.5;
                        g2 = g2 * g2 * (3.0 - 2.0 * g2);
                        c += vec3(0.05, 0.01, 0.03) * g2; 

                        // 4. Dithering (æŠ–åŠ¨) æ ¸å¿ƒä¿®å¤è‰²å¸¦
                        // åœ¨æœ€ç»ˆé¢œè‰²ä¸Šå åŠ æå…¶å¾®å°çš„éšæœºå™ªå£°ï¼Œæ‰“ç ´è‰²é˜¶
                        float noise = (random(gl_FragCoord.xy) - 0.5) / 255.0;
                        c += vec3(noise);

                        gl_FragColor = vec4(c, 1.0);
                    }
                `
            });
            
            // åˆ›å»ºå¤©ç©ºç›’å¹¶èµ‹å€¼ç»™å…¨å±€å˜é‡
            skybox = new THREE.Mesh(new THREE.SphereGeometry(5000, 32, 32), skyMat);
            skybox.frustumCulled = false; // æ°¸ä¸è£å‰ª
            skybox.renderOrder = -999;    // æœ€å…ˆæ¸²æŸ“
            Graph.scene().add(skybox);

        }, 1500);

        // å…¨å±€äº¤äº’çŠ¶æ€ç®¡ç†
        let isInteractionHover = false;
        
        // ç»Ÿä¸€æ£€æµ‹çŒ«çŒ«æ˜¯å¦åº”è¯¥å…´å¥‹
        function updateCatExcitement() {
            const cat = document.getElementById('helicopter-cat');
            if(!cat) return;
            // åªè¦æœ‰ hoveredNode æˆ–è€… é¼ æ ‡åœ¨ interactive å…ƒç´ ä¸Šï¼Œå°±å…´å¥‹
            if(hoverNode || isInteractionHover) {
                cat.classList.add('excited');
            } else {
                cat.classList.remove('excited');
            }
        }

        // ç›‘å¬ DOM å…ƒç´ äº¤äº’ (Markdown é“¾æ¥, æŒ‰é’®, å…³é—­X ç­‰)
        const interactiveSelectors = 'a, button, .close-btn, .tag-capsule, .search-item, .clickable, input, .cat-interactive';
        document.body.addEventListener('mouseover', (e) => {
            if(e.target.closest(interactiveSelectors)) {
                isInteractionHover = true;
                updateCatExcitement();
            }
        });
        document.body.addEventListener('mouseout', (e) => {
            // ç¨å¾®å»¶è¿Ÿåˆ¤æ–­ï¼Œé˜²æ­¢åœ¨ç›¸é‚»å…ƒç´ ç§»åŠ¨æ—¶é—ªçƒï¼Œæˆ–è€…æ£€æŸ¥ relatedTarget
            if(!e.relatedTarget || !e.relatedTarget.closest(interactiveSelectors)) {
                isInteractionHover = false;
                updateCatExcitement();
            }
        });

        // çŒ«çŒ«è·Ÿéšç³»ç»Ÿ (ä½œä¸ºä¼™ä¼´è·Ÿéšåœ¨é¼ æ ‡å³ä¸‹è§’)
        const cat = document.getElementById('helicopter-cat');
        if(cat) {
            const body = cat.querySelector('.cat-body-container');
            const lEye = cat.querySelector('.eye.left'), rEye = cat.querySelector('.eye.right'), zzz = document.getElementById('zzz-bubble');
            
            // mx, my: é¼ æ ‡çœŸå®ä½ç½®
            // cx, cy: çŒ«çŒ«å½“å‰ä½ç½® (Lerped)
            let mx=window.innerWidth/2, my=window.innerHeight/2;
            let cx=mx, cy=my;
            let rot=0, sleeping=false, lastT=Date.now();
            
            document.addEventListener('mousemove', e=>{ 
                mx = e.clientX; 
                my = e.clientY; 
                lastT = Date.now(); 
                if(sleeping) wake(); 
            });
            
            function wake() { sleeping=false; lEye.classList.remove('closed'); rEye.classList.remove('closed'); zzz.classList.remove('active'); blink(); }
            function sleep() { sleeping=true; lEye.classList.add('closed'); rEye.classList.add('closed'); zzz.classList.add('active'); }
            function blink() { if(sleeping)return; lEye.classList.add('closed'); rEye.classList.add('closed'); setTimeout(()=>{if(!sleeping){lEye.classList.remove('closed');rEye.classList.remove('closed')}}, 200); setTimeout(blink, 2000+Math.random()*3000); }
            setTimeout(blink,2000);

            function loop() {
                if(!sleeping && Date.now()-lastT>5000) sleep();
                
                // ç›®æ ‡ä½ç½®ï¼šé¼ æ ‡å³ä¸‹è§’ 24px å¤„
                const targetX = mx + 24;
                const targetY = my + 24;

                // ç®€å•çš„ Lerp è·Ÿéšï¼Œç³»æ•° 0.12 æ¯”è¾ƒè·Ÿæ‰‹ä½†æœ‰å¼¹æ€§
                cx += (targetX - cx) * 0.12;
                cy += (targetY - cy) * 0.12;

                cat.style.left = cx + 'px';
                cat.style.top = cy + 'px';
                
                // æ ¹æ®æ°´å¹³ç§»åŠ¨é€Ÿåº¦è®¡ç®—å€¾æ–œ
                // æ­¤æ—¶ cx åœ¨è¿½èµ¶ targetX(å³ mx), æ‰€ä»¥ vx = (mx - cx) ä¹Ÿå¯ä»¥
                // ä½†å®é™…ä¸Šç›´æ¥ç”¨å½“å‰å¸§ä½ç§»æ›´å‡†ç¡®: velocity = current_cx - prev_cx (è¿™é‡Œç®€åŒ–å¤„ç†)
                let vx = (targetX - cx); 
                
                // é™åˆ¶å€¾æ–œè§’åº¦
                let tr = Math.max(-25, Math.min(25, vx * -1.5));
                
                rot += (tr - rot) * 0.1;
                
                // å°†æ—‹è½¬åº”ç”¨åœ¨å†…éƒ¨å®¹å™¨
                body.style.transform = `rotate(${rot}deg)`;
                
                requestAnimationFrame(loop);
            }
            loop();
        }
        window.onresize = () => Graph.width(window.innerWidth).height(window.innerHeight);
    </script>
</body>
</html>